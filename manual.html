<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>PriDE 3 User Manual</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="assets/css/main.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
		<div class="subpage-menu">
			<a href="http://pride.pm"><i class="fa fa-home"></i> Home</a>
		</div>
		<section id="three" class="wrapper">
			<div class="inner">
<header id="title-block-header">
<h1 class="title">PriDE 3 User Manual</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#about-pride">About PriDE</a><ul>
<li><a href="#about-this-manual">About this manual</a></li>
</ul></li>
<li><a href="#quick-start-tutorial">Quick Start Tutorial</a><ul>
<li><a href="#preparing-the-development-project">Preparing the development project</a></li>
<li><a href="#database-table-design">Database table design</a></li>
<li><a href="#writing-or-generating-entity-classes">Writing or generating entity classes</a></li>
<li><a href="#writing-application-classes">Writing application classes</a></li>
<li><a href="#running-the-application">Running the application</a></li>
<li><a href="#before-you-go-ahead">Before you go ahead…</a></li>
</ul></li>
<li><a href="#entity-adapter-and-descriptor">Entity, Adapter, and Descriptor</a><ul>
<li><a href="#descriptor-structure">Descriptor structure</a></li>
</ul></li>
<li><a href="#find-and-query">Find and Query</a><ul>
<li><a href="#find">Find</a></li>
<li><a href="#query">Query</a><ul>
<li><a href="#streaming">Streaming</a></li>
</ul></li>
<li><a href="#selection-criteria">Selection criteria</a><ul>
<li><a href="#wherecondition">WhereCondition</a></li>
<li><a href="#arbitrary-criteria">Arbitrary Criteria</a></li>
</ul></li>
</ul></li>
<li><a href="#insert-update-and-delete">Insert, Update, and Delete</a><ul>
<li><a href="#insert">Insert</a></li>
<li><a href="#transactions">Transactions</a></li>
<li><a href="#update">Update</a></li>
<li><a href="#delete">Delete</a></li>
</ul></li>
<li><a href="#entity-inheritance">Entity Inheritance</a><ul>
<li><a href="#inheritance-with-separate-adapters">Inheritance with separate adapters</a></li>
</ul></li>
<li><a href="#sql-expression-builder">SQL Expression Builder</a><ul>
<li><a href="#elaborated-sql-vs.-java">Elaborated SQL vs. Java</a></li>
<li><a href="#elaborated-sql-with-sqlexpressionbuilder">Elaborated SQL with SQLExpressionBuilder</a></li>
<li><a href="#building-and-formatting">Building and Formatting</a></li>
</ul></li>
<li><a href="#joins">Joins</a><ul>
<li><a href="#joining-table-fragments">Joining Table Fragments</a></li>
<li><a href="#joining-entities-with-fragments">Joining Entities with Fragments</a></li>
<li><a href="#entity-composition">Entity Composition</a></li>
<li><a href="#ad-hoc-joins">Ad-hoc Joins</a></li>
</ul></li>
</ul>
</nav>
<h1 id="about-pride">About PriDE</h1>
<p>PriDE is the Java world’s smallest object-relational mapper for SQL databases. O/R mapping is the wide-spread approach to map records of a relation SQL database to objects of an object-oriented application. The application should operate on its persistent entities as object-oriented as possible, not regarding that some of them come from a database or must be saved in one. PriDE provides functionality to</p>
<ul>
<li>Describe the mapping of database tables to Java classes</li>
<li>Read and write data records without accessing the complicated JDBC interface, and - as far as possible - don’t write any SQL at all</li>
<li>Simplify the assembly of complicated SQL expressions and selection conditions</li>
</ul>
<p>While O/R mapping is usually based on single-object operations, PriDE also supports efficient database mass processing within Java. The goal is to avoid shifting application logic into procedures within the database as far as possible and not to break the DRY principle. However, if stored procedures and functions are required sometimes, PriDE provides a convenient way to call them.</p>
<p>PriDE was designed for usage in JSE and JEE environments and is used identically everywhere except some initialization operations and the transaction management. The framework follows a very pragmatic approach to provide basic development support quickly and easily. It does not claim to conform with established persistence management standards but follows common design patterns and proved to be suitable in mission-critical projects over many years. The <a href="#feature-list">detailed feature list</a> may help to figure out whether PriDE meets the requirements of individual development projects, and allows to roughly compare this toolkit with existing well-known O/R mapping products and standards like JPA, JOOQ or MyBatis.</p>
<p>PriDE is so small that it can actually be understood in any single line of its code, providing the developer full control over how data is exchanged between an SQL database and a Java application. The runtime library is less than 200 kByte in size without any dependencies beside the JDBC driver library of the database in use.</p>
<p>Did you ever wonder how to conveniently access your SQLite database in a mobile application which has to keep its footprint small? Well, here is your answer :-)</p>
<p>Or did you ever worked in a multi-million lines of code project and got the feeling that JPA magic causes more loss of control than convenience? Guess what the alternative may be.</p>
<p>The chapter <a href="#pride-design-principles">PriDE design principles</a> gives an overview about the concepts which the framework is based on. However, before diving into more theory, it is recommended to walk through the <a href="#quick-start-tutorial">quick start tutorial</a> and get into touch with the real world.</p>
<h2 id="about-this-manual">About this manual</h2>
<p>This manual gives you a complete overview about PriDE’s standard functionality, design patterns and design principles. It is not mandatory to work through all the details unless you want to become an expert. However, it is strongly recommended to begin with the <a href="#quick-start-tutorial">quick start tutorial</a> as many code fragments in other chapters come back to the quick start example. The chapters <a href="#find-and-query">Find and Query</a> and <a href="#insert-update-and-delete">Insert, Update, and Delete</a> describe the core functionality you should become familiar with. All other chapters describe special aspects which you can dive into, when the time has come.</p>
<p>Many code fragments in this manual refer to existing example code which is available in an <a href="https://github.com/j-pride/manual-example-code">appropriate repository on GitHub</a>. The repository includes a <a href="https://github.com/j-pride/manual-example-code/blob/master/pom.xml">pom.xml</a> file to run all examples on a local SQLite database. To have all source code at your fingertips at any time it is recommended to</p>
<ul>
<li>clone the repository (<code>git clone https://github.com/j-pride/manual-example-code.git</code>) and</li>
<li>build the project using Maven (<code>mvn clean compile</code>)</li>
</ul>
<p>At January 2019, the PriDE 3 manual is work in progress. Beside the core chapters above there are chapters coming soon for the following aspects</p>
<h4 id="optimistic-locking">Optimistic Locking</h4>
<h4 id="jse-jee-and-resourceaccessor">JSE, JEE, and ResourceAccessor</h4>
<h4 id="multiple-databases">Multiple Databases</h4>
<h4 id="mass-operations">Mass Operations</h4>
<h4 id="calling-stored-procedures">Calling Stored Procedures</h4>
<h4 id="pride-design-principles">PriDE Design Principles</h4>
<p>A good information source for features which are not yet covered by this manual are PriDE’s unit tests which you can find on <a href="https://github.com/j-pride/pride.pm/tree/master/src/test/java/basic">GitHub</a>. You may also consult the manual from PriDE version 2 which is available on <a href="http://pride.sourceforge.net/PriDE.html">SourceForge</a>.</p>
<h1 id="quick-start-tutorial">Quick Start Tutorial</h1>
<p>This short tutorial gives an introduction into the general working principles of PriDE, based on a simple example. It takes less than half an hour to set up a simple PriDE application which allows to perform basic operations on a single database table. The package <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/quickstart">quickstart</a> of the <a href="https://github.com/j-pride/manual-example-code/">PriDE manual example code repository on GitHub</a> contains the complete source code for the tutorial example.</p>
<p>Setting up an application includes the following steps:</p>
<ul>
<li>Preparing the development project</li>
<li>Database table design</li>
<li>Writing or generating entity classes</li>
<li>Writing application classes</li>
<li>Running the application</li>
</ul>
<p>I.e. there’s only a few minutes time for each step now, so let’s hurry up ;-)</p>
<h2 id="preparing-the-development-project">Preparing the development project</h2>
<p>Working with PriDE requires to add the library pride-x-y-z.jar into the CLASSPATH of the working environment, as well as the JDBC driver of the database to access. E.g. in case of a MySQL 6 database this is the library mysql-connector-java-6.y.z.jar, for Oracle 11 the library ojdbc8.jar, for HSQL 2.x the library hsqldb-2.y.z.jar, and for SQLite 3 the library sqlite-jdbc-3.y.z.jar. The ultra light database SQLite in server-less mode is the best choice for first experiments. You may set up a playground project by cloning PriDE’s <a href="https://github.com/j-pride/manual-example-code">manual examples source code repository on GitHub</a> and compile its sources with Maven, using the included <a href="https://github.com/j-pride/manual-example-code/blob/master/pom.xml">pom.xml</a>. However, as PriDE and SQLite do not depend on any other libraries, you can easily download the PriDE and SQLite JAR files from Maven central and create a project with any technique you like.</p>
<p>Driver class, database URL, database user, and password are supposed to be provided as system properties in this tutorial examples. For SQLite and a local example database, user and password can be omitted and the properties look like this:</p>
<pre><code>pride.dbtype=sqlite
pride.driver=org.sqlite.JDBC
pride.db=jdbc:sqlite:pride.examples.db
pride.logfile=sql.log</code></pre>
<p>Providing the DB type is recommended, to keep PriDE from making a wrong guess, and logging all SQL operations is usually a good idea - especially for beginners.</p>
<h2 id="database-table-design">Database table design</h2>
<p>PriDE follows a database-first approach, so in the next step, the required database table must be designed. PriDE does not provide its own tool for that but assumes one being included in your database installation. If nothing appropriate is around, their are lots of tools available for that, e.g. the free <a href="http://www.dbdesigner.net">DB Designer</a> online tool which supports various common databases. The tutorial examples uses a database table according to the following definition:</p>
<pre><code>create table CUSTOMER (
    id integer not null primary key,
    name varchar(20),
    first_name varchar(30)
);</code></pre>
<p>Add this table now to your SQLite database, using SQLite’s command shell or by running class <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/quickstart/CreateCustomerTable.java">CreateCustomerTable</a> included in the PriDE manual example code:</p>
<pre><code>java
-Dpride.dbtype=sqlite
-Dpride.driver=org.sqlite.JDBC
-Dpride.db=jdbc:sqlite:pride.examples.db
-Dpride.logfile=sql.log
util.CreateCustomerTable</code></pre>
<h2 id="writing-or-generating-entity-classes">Writing or generating entity classes</h2>
<p>Accessing a table via PriDE requires a corresponding entity class (usually a simple Java Bean) and a mapping descriptor object. 1:1 mappings of a database table to a Java class can be generated with a code generator provided with PriDE. For the table CUSTOMER above, the source code for a corresponding entity class Customer and an incorporated descriptor can be generated by the following call:</p>
<pre><code>java
-Dpride.dbtype=sqlite
-Dpride.driver=org.sqlite.JDBC
-Dpride.db=jdbc:sqlite:pride.examples.db
-Dpride.logfile=sql.log
pm.pride.util.generator.EntityGenerator CUSTOMER quickstart.Customer &gt; Customer.java</code></pre>
<p>The generator writes its output to the console, so you can either redirect the output to file as you see above or create the class in the IDE of your choice and copy the output from the console to your class editor. Note that you may also generate the descriptive parts in a <em>separate</em> class to keep the entity bean class free from database aspects. For the tutorial example we generate a hybrid class which looks like this:</p>
<pre><code>public class Customer extends MappedObject {
    public static final String TABLE = &quot;CUSTOMER&quot;;
    public static final String COL_ID = &quot;id&quot;;
    public static final String COL_NAME = &quot;name&quot;;
    public static final String COL_FIRST_NAME = &quot;first_name&quot;;

    protected static final RecordDescriptor red =
      new RecordDescriptor(Customer.class, TABLE, null)
        .row(COL_ID, &quot;getId&quot;, &quot;setId&quot;)
        .row(COL_NAME, &quot;getName&quot;, &quot;setName&quot;)
        .row(COL_FIRST_NAME, &quot;getFirstName&quot;, &quot;setFirstName&quot;);

    public RecordDescriptor getDescriptor() { return red; }

    private static String[] keyFields =
      new String[] { COL_ID };
    public String[] getKeyFields() { return keyFields; }

    private long id;
    private String name;
    private String firstName;

    // Read access functions
    public long getId()   { return id; }
    public String getName()   { return name; }
    public String getFirstName()   { return firstName; }

    // Write access functions
    public void setId(long id) { this.id = id; }
    public void setName(String name) { this.name = name; }
    public void setFirstName(String firstName) { this.firstName = firstName; }


    // Reconstructor
    public Customer(long id) throws SQLException {
        setId(id);
        find();
    }

    public Customer() {}

}</code></pre>
<p>Without going into details now, you can see an important design principle of PriDE: the mapping descriptor is code. You won’t find any descriptive languages included in PriDE - neither XML nor property nor JSON files. Everything in PriDE is Java code and can be examined with a debugger if necessary.</p>
<h2 id="writing-application-classes">Writing application classes</h2>
<p>Based on the entity classes, you can design the actual application. First of all the PriDE runtime library must be initialized by a so-called “resource accessor”. A JSE application requires only a single line of code for an initialization based on system properties:</p>
<pre><code>ResourceAccessorJSE.fromSystemProperties();</code></pre>
<p>The database operations are performed by invoking corresponding member functions of the entity classes, e.g.</p>
<pre><code>public void create(int id, String name, String firstName)
    throws SQLException {
    Customer c = new Customer(id, name, firstName);
    c.create();
}

public void update(int id, String name, String firstName)
    throws SQLException {
    Customer c = new Customer(id, name, firstName);
    c.update();
}

public void queryByName( String name )
    throws SQLException {
    Customer c = new Customer(0, name, null);
    ResultIterator ri = c.query(COL_NAME);
    if (ri != null) {
        do {
            System.out.println(
                c.getId() + &quot;: &quot; +
                c.getName() + &quot;,&quot; +
                c.getFirstName());
        } while(ri.next());
    }
}</code></pre>
<h2 id="running-the-application">Running the application</h2>
<p>The tutorial example on <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/quickstart">GitHub</a> includes the class <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/quickstart/CustomerClient.java">CustomerClient</a>, providing an interactive test client. Calling the client with its system property based initialization looks like this:</p>
<pre><code>java
-Dpride.dbtype=sqlite
-Dpride.driver=org.sqlite.JDBC
-Dpride.db=jdbc:sqlite:pride.examples.db
-Dpride.logfile=sql.log
quickstart.CustomerClient</code></pre>
<p>Play around with the client and then check the working directory. You will find a file sql.log created by PriDE which logs all the SQL statements that resulted from your persistence operation calls. The log file is plain SQL, so if you encounter any unexpected persistence behavior in you application, you can copy the commands from the log and run them from you database’s SQL shell. This is a big advantage over the command logging of most other persistence frameworks.</p>
<p>Actually PriDE is working with plain SQL by default rather than with so-called “bind variables”. So what you see in the log file is exactly what PriDE executes against the database resp. its JDBC driver. If you like to change to bind variables as default, you can add the configuration property <code>-Dpride.bindvars=on</code>. Restart the CustomerClient with this system property set, run some commands and check the log file again. You still see plain SQL but the values of insert and select statements are now preceded by a ? indicating that the value was passed to the database via a bind variable. You can still copy every command from the log to an SQL shell - you only have to remove its question marks before running it interactively. You won’t find many persistence managers with a comfortable SQL logging like that.</p>
<p>A meaningful usage of bind variables becomes a relevant issue for heavily accessed databases and will be discussed in the <a href="#mass-operations">mass operation chapter</a>.</p>
<h4 id="thats-it">That’s it!</h4>
<p>The tutorial example already introduces the most important basic elements of PriDE. To understand what’s going on behind the scenes of the 5 steps above, you will find all aspects explained in detail in the manual.</p>
<h2 id="before-you-go-ahead">Before you go ahead…</h2>
<p>Before you go on you should simplify the configuration in a way that you don’t have to provide system properties every time you call a client. Although PriDE does not <em>require</em> any descriptive languages, they are sometimes quite helpful. To simplify the playing-around with examples, all client programs included in the PriDE manual examples use the class <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/util/ResourceAccessorExampleConfig.java">util.ResourceAccessorExampleConfig</a> for initialization. It allows to assemble the configuration from two sources: system properties as it was introduced so far and a property file <a href="https://github.com/j-pride/manual-example-code/blob/master/config/pride.examples.config.properties">config/pride.examples.config.properties</a>. As the configuration properties probably stay unchanged through all your experiments, you should transfer all your command line system properties to file (without the leading “-D” of course) and start your client programs without passing any system properties at all. To run the entity generator with the file-based configuration call the wrapper class <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/util/EntityGeneratorWithExampleConfig.java">util.EntityGeneratorWithExampleConfig</a> which is also included in the examples.</p>
<h1 id="entity-adapter-and-descriptor">Entity, Adapter, and Descriptor</h1>
<p>The concept of O/R mapping requires three basic building blocks:</p>
<ul>
<li>Entity classes which representing data in SQL tables - in the most common usage one entity object represents one record in one SQL table</li>
<li>Descriptors, describing how the entity classes map to the database</li>
<li>An adapter which reads data from the database to entities (select) and writes data from entities to the database (insert, update, delete)</li>
</ul>
<p>There are very different approaches around how to express the descriptor. JPA uses annotations on entity classes, MyBatis uses XML files, and PriDE follows a different approach as you may have seen already from the <a href="#quick-start-tutorial">quick start tutorial</a>. The descriptor is an instance of class pm.pride.RecordDescriptor, i.e. it is code itself. This concept has a few advantages over other approaches.</p>
<ul>
<li>It does not clutter the entity classes with database details, so entities can be passed around in the application without violating the information hiding principle. If you are familiar with JPA you may have experienced the problem that mapping annotations can pile up to an annoying amount.</li>
<li>Its not written in a different language which is always hard to keep in sync with the Java code. This becomes a serious problem when applications grow over time. If you are only working with three database tables, you won’t have this problem, of course.</li>
<li>If it is Java code, it can be tied to any other related Java code by using shared constants for table named and row names and so on. This allows you to easily keep track of dependencies in the code. E.g. if you remove a column from a database table you will remove the appropriate constant in the code and every mentionable IDE will immediately lead you to all the places in the code that do not compile any more. This will include the descriptor as well as all the database queries in the code that refer to that column.</li>
<li>Descriptors may also be assembled dynamically at runtime. You hopefully will not often run into situations where you need that, but its good to know that there is no limit on that.</li>
</ul>
<p>A coded descriptor needs to go somewhere in your code, of course. PriDE provides two default patterns for the descriptor placement which are obvious when you think of the building blocks mentioned above: descriptors within adapter classes or descriptors within entity classes.</p>
<p>Descriptors in entities is what you know already from the <a href="#quick-start-tutorial">quick start tutorial</a>. It cases the entities to become their own adapters having their own persistence methods. This is a compact pattern which is suitable for small applications. Therefore you will find it spread over most examples provided with PriDE. The disadvantage is the same one mentioned above with JPA: the entity classes spread knowledge about database mapping information all over the code. Combined with persistence capabilities directly incorporated in entity classes, this is a questionable concept in bigger architectures.</p>
<p>Let’s have a look on the more sophisticated pattern of separate adapter classes. You can have a look on the general structure by generating separate classes for the quick start example table. The pure entity class can be generated by the following command:</p>
<pre><code>java
-D... see quick start tutorial
pm.pride.util.generator.EntityGenerator CUSTOMER adapter.CustomerEntity -b &gt; CustomerEntity.java</code></pre>
<p>The parameter -b tells the generator to create only an entity class without descriptor. The result is an ordinary Java bean or POJO class:</p>
<pre><code>package adapter;

public class CustomerEntity implements Cloneable, java.io.Serializable {
    private long id;
    private String name;
    private String firstName;

    public long getId()   { return id; }
    public String getName()   { return name; }
    public String getFirstName()   { return firstName; }

    public void setId(long id) { this.id = id; }
    public void setName(String name) { this.name = name; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    // re-constructor
    public CustomerEntity(long id) {
        setId(id);
    }

    public CustomerEntity() {}
}</code></pre>
<p>The “re-constructor” is an additional constructor getting passed a value for all the attributes making up the entity’s primary key. This of interest for find operations.</p>
<p>Generating the corresponding adapter class looks like this:</p>
<pre><code>java
-D... see quick start tutorial
pm.pride.util.generator.EntityGenerator CUSTOMER adapter.CustomerAdapter adapter.CustomerEntity &gt; CustomerAdapter.java</code></pre>
<p>The first parameter after the table name specifies the class to generate - in this case a class called CustomerAdapter in package adapter. The second parameter is the name of a entity class the adapter should refer to. The result looks like this:</p>
<pre><code>package adapter;

public class CustomerAdapter extends ObjectAdapter {
    public static final String TABLE = &quot;CUSTOMER&quot;;
    public static final String COL_ID = &quot;id&quot;;
    public static final String COL_NAME = &quot;name&quot;;
    public static final String COL_FIRST_NAME = &quot;first_name&quot;;

    protected static final RecordDescriptor red =
      new RecordDescriptor(CustomerEntity.class, TABLE, null)
        .row(COL_ID, &quot;getId&quot;, &quot;setId&quot;)
        .row(COL_NAME, &quot;getName&quot;, &quot;setName&quot;)
        .row(COL_FIRST_NAME, &quot;getFirstName&quot;, &quot;setFirstName&quot;);

    public RecordDescriptor getDescriptor() { return red; }

    private static String[] keyFields = new String[] { COL_ID };
    public String[] getKeyFields() { return keyFields; }

    CustomerAdapter(CustomerEntity entity) { super(entity); }
}</code></pre>
<p>All what the adapter class has to provide is a RecordDescriptor and an optional list of column names making up the entity’s primary key. Based on that, the class inherits all entity-related persistence capabilities from class pm.pride.ObjectAdapter. Adapters always operate on an instance of the entity class which must be passed in the adapter’s constructor. Finding a customer by its primary ID looks like this when using separate adapter classes:</p>
<pre><code>// Create a customer entity, initialized with a primary key value of 1
CustomerEntity customer = new CustomerEntity(1);

// Create an adapter based on the entity
CustomerAdapter adapter = new CustomerAdapter(customer);

// Call the adapter&#39;s find method to find a customer by primary key 1.
// The primary key value is read from the entity passed in the adapter&#39;s constructor
// The result (if any) is written to the same entity
adapter.find();</code></pre>
<p>As you see, every persistence operation now requires one additional line of code to create the adapter. Especially when you design a multi-threaded application, it is important to know that adapter and entity instances are not supposed to be shared among multiple threads. So creating new instances in every operation is the prefered technique and is usually not a considerable code complication.</p>
<p>If you want to minimize the amount of code, you are free to invent your own adapter concept. Have a look on the base classes pm.pride.ObjectAdapter for the adapter above and pm.pride.MappedObject for the hybrid variant from the <a href="#quick-start-tutorial">quick start tutorial</a>. Both are minimalistic implementations of the mix-in pm.pride.DatabaseAdapterMixin which is the actual provider for all entity-related persistence operations. It is in turn based on the static methods of the class pm.pride.DatabaseAdapter. Using this class or the mix-in you could easily produce a generic adapter being responsible for multiple entity types similar to JPA’s EntityManager interface.</p>
<p>One note concerning packages: When you actually use the pattern of separate adapters in a sophisticated architecture, you should consider generating entity and adapter classes in different packages. Only the entity classes should be part of the interface for dependent code while the adapter classes should completely be hidden behind facade components as proposed in the wide-spread <a href="https://martinfowler.com/eaaCatalog/repository.html">repository pattern</a>.</p>
<h2 id="descriptor-structure">Descriptor structure</h2>
<p>The examples for descriptors you have seen so far should already clarify most of the descriptor structure. You will see more complicated examples in following chapters of this manual. A descriptor is assembled from the following information:</p>
<ul>
<li><p>The name of the entity class and the name of the database table which the entity class is mapped to. Preferably the table name is not specified as a string-literal but as a reference to a constant representing the table name. If you have a look on the outcome of PriDE’s code generator, there are appropriate constants generated and used.</p></li>
<li><p>A reference to the descriptor of a base class. This is of interest when you build up an inheritance hierarchy between entity classes as explained in chapter <a href="#entity-inheritance">Entity Inheritance</a>.</p></li>
<li><p>A table row to attribute mapping by adding calls of the row() method for every row of interest. The row() method returns the descriptor object, making up a fluent API. Every row/attribute mapping consists of</p>
<ul>
<li>The name of the database column (similar to table names: avoid using string-literals here)</li>
<li>The name of the getter method for the corresponding attribute in the entity class</li>
<li>The name of the setter method</li>
</ul>
<p>The methods are the ones which the adapter is supposed to use for transporting entity attributes to the database via JDBC and vice versa. The getter methods’ return type implies which methods the adapter uses to access JDBC statements and result sets and how to translate the values to SQL syntax. Getters are mandatory whereas setters may be null in case of entity types that are never supposed to be written to the database. A typical example for this case are entity classes representing the result of SQL joins (see chapter <a href="#joins">Joins</a>).</p></li>
</ul>
<p>The RecordDescriptor class has a few more constructors concerned with joins and <a href="#multiple-databases">accessing multiple databases</a>, but that’s not important for now. The basic structure described above is what you work with most of the time.</p>
<h1 id="find-and-query">Find and Query</h1>
<p>The terms “find” and “query” for data retrieval are used in the same sense in PriDE as you may know it from other persistence concepts. Finding means to select data with the expectation to retrieve 1 result or none treating the presence of multiple results as an exception case. The most common example is a selection by primary key.</p>
<p>A query means to select data with an unpredictable number of result. PriDE is designed to take “unpredictable” literally and allows to process even millions of results in an efficient way in Java.</p>
<h2 id="find">Find</h2>
<p>Examples for finding a record with PriDE were already part of the <a href="#quick-start-tutorial">quick start tutorial</a> and the chapter about <a href="#entity-adapter-and-descriptor">entity, adapter, and descriptor</a>. But let’s go into some details here for a deeper understanding. The important things to know:</p>
<ul>
<li>No matter if you are working with hybrid objects or a separation of entity and adapter - PriDE doesn’t creates entities for you but expects you to provide them.</li>
<li>Find operations work like a query-by-example. You provide an entity with all the primary key fields initialized and call the find() or findx() method without parameters. This is a method of the entity class itself when using hybrid entities, otherwise it is a method of the corresponding adapter class.</li>
<li>The result of the find operation is placed in the same entity which you provided the key fields by. The boolean return value of the find() method tells the caller if there was actually a matching record found. The findx() method reports a missing match by an exception which if of interest for situations where a missing result is a unexpected case. Think of typical navigation like retrieving the customer who placed an order. You usually don’t expect the customer not being present in the database.</li>
</ul>
<p>When you are working with a generated hybrid entity, a find operation by primary key fields is a single line of code like that:</p>
<pre><code>Customer customer = new Customer(1);</code></pre>
<p>PriDE’s generator produces a so-called “re-constructor” if the referred database table has a primary key. The re-constructor expects a parameter for all attributes making up the primary key, initializes the entity accordingly and calls the entity’s findx() method. I.e. if the retrieval by primary key fails, the re-constructor throws a pm.pride.FindException. The FindException is derived from java.sql.SQLException which must be handled anyway.</p>
<p>When you are working with separate adapter classes, the same operation takes two lines of code:</p>
<pre><code>CustomerEntity customer = new CustomerEntity(1);
new CustomerAdapter(customer).findx();</code></pre>
<p>Why isn’t it simpler, e.g.</p>
<pre><code>// ATTENTION: This is NOT default PriDE code!!
CustomerEntity customer = new CustomerAdapter().findx(1);
// This isn&#39;t too
CustomerEntity customer = entityManager.findx(CustomerEntity.class, 1);</code></pre>
<p>Well, all these variants imply that the adapter creates an entity, and this would violate a basic principle of PriDE. However, as mentioned in chapter <a href="entity-adapter-and-descriptor">Entity, Adapter, and Descriptor</a>, you are free to put those concepts on top of PriDE’s basics. PriDE is really, really small and simple and extending it by your own convenience is simple too.</p>
<h2 id="query">Query</h2>
<p>Whenever selecting multiple records from the database, PriDE returns a pm.pride.ResultIterator to iterate through the results. The ResultIterator encapsulates a java.sql.ResultSet, i.e. it is an open database cursor which is suitable for any amount of results. Taking up the example from the <a href="#quick-start-tutorial">quick start tutorial</a>, you can select all customers from the CUSTOMER table by the following lines of code:</p>
<pre><code>Customer customer = new Customer();
ResultIterator ri = customer.queryAll();</code></pre>
<p>To allow the processing of large amounts of records, the ResultIterator works slightly different from what you may be used to.</p>
<ul>
<li>To step through the results, you have to call the iterators next() method which returns false if there are no more results available.</li>
<li>Instead of creating a new entity with every step, the iterator provides all results in the entity which the query was initiated from. I.e. every call of next() overwrites the data from the step before. No matter how many results you have, you will not run into memory problems when you directly process the results within the iteration loop.</li>
<li>The first result from the query gets initially written to the entity, so the iteration process usually requires a do-while-loop rather than a while-loop.</li>
<li>If there are no results at all, the query functions returns a ResultIterator which returns true from its isNull() method.</li>
</ul>
<p>Pulling all this together, an iteration for direct result processing looks like that, e.g. if we would like to print all customers to the console:</p>
<pre><code>Customer customer = new Customer();
ResultIterator ri = customer.queryAll();
if (!ri.isNull()) {
    do {
        System.out.println(customer);
    }
    while(ri.next());
}
else {
    System.out.println(&quot;No customers found&quot;);
}</code></pre>
<p>A ResultIterator must be closed when the iteration is over, because it holds an open java.sql.ResultSet inside which in turn holds an open database connection. For convenience, the ResultIterator closes its ResultSet automatically when your code iterates to the end or if there occurs a database exception while fetching results. So usually you don’t have to care about closing the iterator. For special cases, call the close() method.</p>
<p>The direct iteration is a highly efficient option on the one hand (PriDE is a lot faster with this approach than any JPA implementation), but on the other hand it is not the typical case. Usually the amount of results is small and they don’t need to be processed on such a low layer of the application. Instead you may want to pass them as a list or array to a higher application layer where the business logic resides in. In this case, you can call appropriate functions on the ResultIterator:</p>
<pre><code>// Extract the customers as list
List&lt;Customer&gt; allCustomers = ri.toList(Customer.class);

// Extract the customers as list with a limitation for the amount of results
List&lt;Customer&gt; allCustomers = ri.toList(Customer.class, 100);

// Extract the customers as array
Customer[] allCustomers = ri.toArray(Customer.class);</code></pre>
<p>Does PriDE create entities here? No, not really. The instances result from <em>cloning</em> the original entity object which the query was initiated from. I.e. the entity class itself is responsible for creating new instances by implementing the java.lang.Clonable interface and overriding the clone() method with public visibility. All entity types generated by PriDE have this function implemented based on Java’s protected default implementation. This is a single-line implementation, so it’s very simple to provide even if you are not using the generator.</p>
<p>In general it is strongly recommended to define a base class for all entity types where all those standard capabilities are encapsulated. Not only a clone() implementation but also s reasonable default (reflection-based) toString() method and maybe even a set of standard attributes as explained in chapter <a href="#entity-inheritance">Entity Inheritance</a>.</p>
<h3 id="streaming">Streaming</h3>
<p>Another alternative form of result processing are the ResultIterator’s stream methods. There are two different methods available.</p>
<p>The method <code>stream(Class)</code> provides the results as a “real” stream with a clone of the original entity for every result. The resulting stream is suitable for any kind of Java stream operations but should be used with care when selecting a very large number of results combined with stream operations which have to keep all the results (e.g. sort and collect operations). This may cause serious memory problems.</p>
<p>The method <code>streamUncloned(Class)</code> provides all results in the original entity just as it is the case in direct iterating and processing demonstrated above. This kind of stream is suitable for any amount of results but can only be used for a limited set of stream operations. Especially operations that rely on object identity will usually not work. Operations for direct processing like forEach() or count() won’t cause any problems. The direct processing example from the beginning of the query section would look like this when using streams:</p>
<pre><code>Customer customer = new Customer();
customer.queryAll().streamUncloned().forEach(c -&gt; System.out.println(c));</code></pre>
<p>Examples for find and query code can by found in the class <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/query/QueryClient.java">QueryClient</a> in the package <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/query">query</a> of the PriDE manual source code repository on GitHub.</p>
<h2 id="selection-criteria">Selection criteria</h2>
<p>PriDE has a few different features to assemble SQL where-clauses for queries:</p>
<ul>
<li>Query by example</li>
<li>The builder class WhereCondition</li>
<li>Completely self-defined conditions</li>
</ul>
<p>Query-by-example is something you already come across in the section about <a href="#find">finder methods</a>. It is addressed by the method queryByExample(String… dbfields) which is available in every adapter and every hybrid entity class. The where-clause is assembled from an equality expression for all the database columns being passed to the function call where the values are taken from the corresponding attributes of the entity. Of course, the entity must be initialized accordingly first. Taking up the Customer entity from the <a href="#quick-start-tutorial">quick start tutorial</a>, the following query-by-example would allow to find all customers with first name “Peter”:</p>
<pre><code>Customer customer = new Customer();
customer.setFirstName(&quot;Peter&quot;);
ResultIterator ri = customer.queryByExample(Customer.COL_FIRST_NAME);</code></pre>
<p>The query takes all the specified columns into account, considering also Null-values in appropriate attributes. E.g. passing Customer.COL_FIRST_NAME, Customer.COL_NAME to the query method without setting a name value in the customer entity, the resulting SQL query will look like this:</p>
<pre><code>select id,name,first_name from CUSTOMER where ( first_name = &#39;Peter&#39; AND name IS NULL )</code></pre>
<p>Remember that yo can always check the SQL log file to find out what SQL statements have been assembled by PriDE. And always remember to use constants for the column names as you can see above rather than string literals. This allows you to keep track of which code depends on which aspects of your data model.</p>
<h3 id="wherecondition">WhereCondition</h3>
<p>Query-by-example is easy to use but limited to equality expressions. A more sophisticated tool in PriDE is the WhereCondition class. It allows to assemble more complicated queries with a fluent API as a compromise between syntax and type safety on the one hand and code readability and simplicity on the other hand. Lets start with a simple example of a where condition, producing the same query as above for an empty name and the first name “Paddy”:</p>
<pre><code>WhereCondition byFirstNameAndEmptyName =
    new WhereCondition(Customer.COL_FIRST_NAME, &quot;Paddy&quot;)
    .and(Customer.COL_NAME, null);
ResultIterator ri = new Customer().query(byFirstNameAndEmptyName);</code></pre>
<p>The basic principle of the class is straight-forward:</p>
<ul>
<li>The function and() creates a sub-condition which is is AND concatenated with the condition being assembled so far. The same applies to the corresponding or() method.</li>
<li>The and() function returns the WhereCondition itself which causes the class and its methods to become a fluent API.</li>
<li>The and() function which only gets passed a field name/value pair produces an equality expression.</li>
<li>The name/value pair passed to the constructor makes up the initial condition. To keep from mixing real constructor parameters with the first condition fragment, it is recommended to use the following form instead:</li>
</ul>
<pre><code>WhereCondition byFirstNameAndEmptyName = new WhereCondition()
    .and(Customer.COL_FIRST_NAME, &quot;Paddy&quot;)
    .and(Customer.COL_NAME, null);
ResultIterator ri = new Customer().query(byFirstNameAndEmptyName);</code></pre>
<p>It doesn’t make a difference if you start with the or() method or the and() method at the top. Both methods are available in the more flexible variant <code>xxx(String field, String operator, Object... value)</code>. The parameter <em>operator</em> is an SQL operator with the commonly known ones listed in the <em>Operator</em> interface within the WhereCondition class. Using String rather than a type-safe Enum keeps the API open for future extensions and vendor-specific operators. Multiple values can be passed for the operators WhereCondition.Operator.BETWEEN and WhereCondition.Operator.IN. E.g. selecting customers with first name “Paddy” or “Mary” can be expressed by</p>
<pre><code>.and(COL_FIRST_NAME, IN, &quot;Paddy&quot;, &quot;Mary&quot;);</code></pre>
<p>The variants <code>xxxNotNull(...)</code> will only add the sub-condition if the (first) field value differs from Null. This is of interest for the assembly of conditions from interactive search criteria input. An empty criterion usually means ‘do not consider’ rather than ‘must be empty’.</p>
<p>The variant without parameters opens up a sub-condition which must be completed by function bracketClose(). The following condition looks for early customers (id less than 1000) that registered with a suspicious name “Mickey Mouse”:</p>
<pre><code>WhereCondition byMickeyMouse = new WhereCondition()
    .and(COL_ID, LESS, 1000)
    .and()
        .or(COL_FIRST_NAME, IN, &quot;Mickey&quot;, &quot;Mouse&quot;)
        .or(COL_NAME, IN, &quot;Mickey&quot;, &quot;Mouse&quot;)
    .bracketClose();</code></pre>
<p>What of you are interested in other suspicious cases where name and first name are equal. In this case, the value is a field name itself and you have to bypass the value formatting. This is achieved by passing pre-formatted SQL values like that:</p>
<pre><code>.and(COL_FIRST_NAME, SQL.pre(COL_NAME))</code></pre>
<p>Finally the WhereCondition can be extended by ordering and grouping clauses. E.g. the following condition selects all customers ordered by name and first name:</p>
<pre><code>new WhereCondition().orderBy(COL_NAME).orderBy(COL_FIRST_NAME)</code></pre>
<p>Especially when you select data <em>in order</em>, the ResultIterator provides the additional methods spoolToList() and spoolToArray() to read results in chunks. This will be explained in more details in chapter <a href="#mass-operations">Mass Operations</a>.</p>
<p>And finally finally the methods bindvars…() in the WhereCondition class give you fine-grained control over which parts of the expression should use bind variables and which ones should be plain SQL. Bind variables or not becomes a relevant issue for databases on heavy duty and therefore are also discussed in the mass operation chapter.</p>
<h3 id="arbitrary-criteria">Arbitrary Criteria</h3>
<p>When the going gets tough there is a method <code>query(String where)</code> available in all adapters and hybrid entities. The function gets passed a fully assembled where-clause without the leading where keyword. It takes any limitations away but also a lot of convenience and safety. Assembly of complicated SQL expressions may not only become an issue in where-clauses but in any multi-record operation likes joins, merge statements, or mass updates. PriDE can help you assembling these expressions with the class pm.pride.SQLExpressionBuilder resp. the function pride.pm.SQL.build(). It preserves the native readability of complicated SQL on the one hand and allows you to work with table name and column name constants on the other hand to preserve code dependency tracking. In the preceding chapters you learned already that the PriDE principles heavily emphasize this central aspect for robust application design. The expression builder is addressed in a <a href="#sql-expression-builder">separate chapter</a>. However, to give you a first impression, here is an example how to build the most complicated expression above - the Mickey Mouse case - using the expression builder:</p>
<pre><code>String byMickeyMouse = SQL.build(
    &quot;@ID &lt; 1000 AND (&quot; +
    &quot;  @FIRST_NAME IN (&#39;Mickey&#39;, &#39;Mouse&#39;) OR &quot; +
    &quot;  @NAME IN (&#39;Mickey&#39;, &#39;Mouse&#39;)&quot; +
    &quot;)&quot;,
    COL_ID, COL_FIRST_NAME, COL_NAME);
ResultIterator ri = new Customer().query(byMickeyMouse);</code></pre>
<p>This is a very limited example but you may already recognize the advantage over using the convenient WhereCondition fluent API: The SQL code is plain to see in nearly its native structure and notation although the actual assembly still makes use of the table and column name constants. The expression string may contain ? characters for bind variables. In this case, the variable values must be appended to the expression in the query() method call. The following example uses that feature for the ID threshold of 1000, making up the same selection as above:</p>
<pre><code>String byMickeyMouse = SQL.build(
    &quot;@ID &lt; ? AND (&quot; +
    &quot;  @FIRST_NAME IN (&#39;Mickey&#39;, &#39;Mouse&#39;) OR &quot; +
    &quot;  @NAME IN (&#39;Mickey&#39;, &#39;Mouse&#39;)&quot; +
    &quot;)&quot;,
    COL_ID, COL_FIRST_NAME, COL_NAME);
ResultIterator ri = new Customer().query(byMickeyMouse, 1000);</code></pre>
<p>Using bind variables is the easiest way for you as a developer to overcome the problem of value formating, which may become a bit tricky for complex data types like dates and timestamps. However, this should of course not be the main reason to use bind variables. See chapter <a href="#mass-operations">Mass Operations</a> for purposeful usage. As long as you are working with small databases, it is OK just to utilize the formatting side effect.</p>
<p>If you want to learn more about the expression builder right now, read the chapter <a href="#sql-expression-builder">SQL Expression Builder</a>.</p>
<h1 id="insert-update-and-delete">Insert, Update, and Delete</h1>
<p>The basic functionality for inserting, updating and deleting data is very simple. In addition to the basics, this chapter also explains how to manage transactions which is of course a very important issue when you manipulate the data. For most code snippets in this chapter you can find example code in package <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/modify">modify</a> in the <a href="https://github.com/j-pride/manual-example-code/">PriDE manual source code repository on GitHub</a>.</p>
<h2 id="insert">Insert</h2>
<p>To insert a record in a database table, you create an instance of the corresponding entity class, set all its attributes and call its create() method:</p>
<pre><code>Customer customer = new Customer();
customer.setId(57);
customer.setName(&quot;Fingal&quot;);
customer.setFirstnae(&quot;Paddy&quot;);
customer.create();</code></pre>
<p>When you are working with separate adapters instead, create() is a method of the adapter and the code looks like that:</p>
<pre><code>CustomerEntity customer = new CustomerEntity();
customer.setId(57);
customer.setName(&quot;Fingal&quot;);
customer.setFirstnae(&quot;Paddy&quot;);
new CustomerAdater(customer).create();</code></pre>
<p>You can insert multiple records successively using the same entity (and adapter) by changing the entity’s data and repeatedly call create(). This is OK for small amounts of inserts. If you have to insert thousands or hundreds of thousands records, you better work with the class pm.pride.PreparedInsert as explained in chapter <a href="#mass-operations">Mass Operations</a>.</p>
<p>If the addressed database table has auto-increment rows, you can specify these rows in the adapter class resp. the hybrid entity class by the method public <code>String[] getAutoFields()</code>. In this case you leave the appropriate attributes uninitialized, and after creation PriDE will set them according to the values generated by the database. Expressing auto-incrementation in a database table definition is always a bit vendor-specific as well as the supported generation features in general. Supposed you are still experimenting with the SQLite database from the <a href="#quick-start-tutorial">Quick Start Tutorial</a>, you could change the CUSTOMER table as follows to make the ID and auto-increment row:</p>
<pre><code>create table CUSTOMER (
    id integer not null primary key AUTOINCREMENT,
    name varchar(20),
    first_name varchar(30)
);</code></pre>
<p>An appropriate hybrid entity class looks exactly like the one from the Quick Start Tutorial only extended by the following line:</p>
<pre><code>public String[] getAutoFields() { return keyFields; }</code></pre>
<p>Based on that, the following loop creates 10 unique test customers in a row and prints out the auto-generated ID of each of them:</p>
<pre><code>Customer customer = new Customer();
for (int i = 0; i &lt; 10; i++) {
    customer.setName(&quot;Fingal-&quot; + i);
    customer.setFirstName(&quot;Paddy-&quot; + i);
    customer.create();
    System.out.println(customer.getId());
}</code></pre>
<p>You find an example for a <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/modify/AutoIncCustomer.java">customer class with auto-increment ID</a> in package <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/modify">modify</a> in the PriDE manual source code repository on GitHub.</p>
<h2 id="transactions">Transactions</h2>
<p>Try to write a loop as above without anything else and you will recognize that it does not produce any rows at all in you CUSTOMER table. Most SQL databases are fully transaction-saved by default and thus require the application to properly commit its work. The foundation for transaction management with commit and rollback is the <a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">ACID principle</a>, which every developer must be well aware of as it is deep-seated in JDBC and every JDBC-based persistence manager.</p>
<p>In a JSE environment you will by default lose all your database work when the application terminates and you forgot to explicitly run a commit operation. In enterprise environments like standard JEE or Spring the application is usually not responsible for ending transactions by programmatic operations. Most applications use so-called container-managed transactions which are implicitly controlled by method annotations and exception handling. This is a very convenient and recommendable technique and it is also the key for composing higher-level methods from calls of lower-level methods in an elegant way according to the <a href="http://principles-wiki.net/principles:single_level_of_abstraction">Single Level of Abstraction Principle</a>. No method has to worry about whether it is the very top-level of the (potentially still growing) composition tree.</p>
<p>PriDE does not really manage transactions by its own but relies on the transaction management of the environment it is used in. The link between PriDE and its environment is the ResourceAccessor interface and you have to install one somewhere in your application. The chapter <a href="#jse-jee-and-resourceaccessor">JSE, JEE, and ResourceAccessor</a> will explain that in detail. Except in this chapter, all other examples in this manual are working on a simple JSE environments and use the class ResourceAccessorJSE. So here is how this resource accessor works concerning its simple connection management and the resulting transaction behavior:</p>
<ul>
<li>As soon as you access the database for the first time, the accessor opens a database connection and binds it to the current thread. I.e. all succeeding database operations within the same thread are performed on the same database connection.</li>
<li>The ResourceAccessorJSE has no connection pooling, i.e. the number of concurrently allocated database connections corresponds to the number of threads requiring access to the database. This is not a suitable model for server applications, but if you implement server components with PriDE, you will hopefully work in a JEE environment.</li>
<li>The current database transaction can be committed by the call <code>DatabaseFactory.getDatabase().commit()</code>. This addresses only the connection being bound to the current thread. After committing, the connection is kept open and related to the thread so that subsequent databases operations run without warming up a new connection.</li>
<li>Alternatively the commit can be initiated from any adapter resp. hybrid entity as well. This is especially of interest when working with multiple databases because the commit then refers to the database which the entity resides in whereas DatabaseFactory.getDatabase() refers to the database which was addressed at last. This will be explained in detail in chapter <a href="#multiple-databases">Multiple Databases</a>. When you are working with a single database, these operations are equivalent.</li>
<li>Instead of committing you may rollback your work by calling the rollback() method either on the database object or an adapter resp. a hybrid entity.</li>
<li>The resource accessor explicitly turns off auto-commit for every allocated connection.</li>
</ul>
<p>Coming back to the example for customer creation above, the code must be completed as follows:</p>
<pre><code>Customer customer = new Customer();
for (int i = 0; i &lt; 10; i++) {
    // see above
}
customer.commit();</code></pre>
<p>As a result the code will either successfully create all 10 customers or non at all because the whole work of the loop is committed at once at the end. If any of the 10 insert operations fails with an exception, the commit call would be skipped. This causes the application to terminate without any commit which in turn causes and implicit rollback. If you write an application which runs for a long time and is supposed to survive severe exceptions (i.e. a UI client), you should pay some attention on making the application robust against accidentally unterminated transactions. A recommended Java feature for an appropriate safety net is the UncaughtExceptionHandler interface. You can install a handler to every thread which preventively performs a rollback call.</p>
<h2 id="update">Update</h2>
<p>Updating a record is performed by calling the update() method of the adapter resp. the hybrid entity. All fields returned from the adapter’s getKeyFields() method are used to identify the record and all other fields are updated. The code</p>
<pre><code>Customer paddy = new Customer(57);
paddy.setFirstName(&quot;Paddy&quot;);
paddy.update();
paddy.commit();</code></pre>
<p>results in the following SQL statements as you can see from the log file:</p>
<pre><code>select id,name,first_name from CUSTOMER where ( id = 57 ) 
update CUSTOMER set name = &#39;Fingal&#39;,first_name = &#39;Paddy&#39; where id = 57</code></pre>
<p>All update calls return the number of affected rows which should be 0 or 1 in case of an update by primary key. It’s up to you if you check the result. PriDE has no detection which attributes actually changed since an entity has been loaded, so it simply updates <em>all</em> attributes which are not part of the primary key. As PriDE has no instance and change management, updates always have to be explicitly performed by the application. If you are familiar with JPA, you may recognize that the concepts are very different concerning this aspect. The chapter <a href="#pride-design-principles">PriDE Design Principles</a> explains why the much simpler approach of PriDE is not a loss.</p>
<p>Updating single rows by update() calls is OK for a limited number of operations per transaction. If you have to update thousands of records instead you should consider working with the class pm.pride.PreparedUpdate as explained in chapter <a href="#mass-operations">Mass Operations</a>.</p>
<p>There are a few variants of the update() method available which allow to update multiple records at once. E.g. the method update(WhereCondition where, String… updatefields) can address the records of interest by a where condition. In these cases there are usually only particular fields requiring an update. The following example demonstrates how to change all first names from “Paddy” to “Patrick”:</p>
<pre><code>Customer customer = new Customer();
customer.setFirstName(&quot;Patrick&quot;);
int updates = customer.update(new WhereCondition(COL_FIRST_NAME, &quot;Paddy&quot;), COL_FIRST_NAME);
customer.commit();
System.out.println(updates + &quot; row(s) updated&quot;);</code></pre>
<p>The code above makes clear that multi-record updates are not necessarily best to understand when they are expressed by entity operations. Have a look on the resulting update statement which is pretty clear to understand:</p>
<pre><code>update CUSTOMER set first_name = &#39;Patrick&#39; where ( first_name = &#39;Paddy&#39; )</code></pre>
<p>If the entity layer is not appropriate, you have a lower level at hand using the class pm.pride.Database. You get access to the current database by the call <code>DatabaseFactory.getDatebase()</code>. Here is how the renaming update looks like with a combination of the Database class and the SQLExpressionBuilder:</p>
<pre><code>Database database = DatabaseFactory.getDatabase();
String operation = SQL.build(
    &quot;update @CUSTOMER set @FIRST_NAME = &#39;Patrick&#39; where ( @FIRST_NAME = &#39;Paddy&#39; ) &quot;,
    TABLE, COL_FIRST_NAME);
int updates = database.sqlUpdate(operation);
database.commit();
System.out.println(updates + &quot; row(s) updated&quot;);</code></pre>
<p>In this example, the SQL code is almost present in its native, well recognizable form but it is still based on the entity’s table and column name constants. The DRY principle and dependency tracking is kept up properly. The commit is performed on the Database instance as explained in section <a href="#transactions">Transactions</a> above.</p>
<h2 id="delete">Delete</h2>
<p>To delete a record you have to call the delete() method of the adapter resp. the hybrid entity. All fields returned from the adapter’s getKeyFields() method are used to identify the record All other fields are ignored, so whether they are initialized or not is irrelevant. The following code deletes the customer with ID 57:</p>
<pre><code>Customer c57 = new Customer();
c57.setId(57);
paddy.delete();
paddy.commit();</code></pre>
<p>Note that the code above is based on a hybrid entity and does <em>not</em> use the re-constructor which would immediately initiate a find operation. Entities don’t have to be loaded before deletion. Just like updates, every deletion returns the number of affected rows and it’s up to you if you check the result.</p>
<p>There is a deleteByExample() method available which allows to specify a different set of key attributes and usually deletes multiple records at once. More complicated multi-record deletions can be performed by the sqlUpdate() method of the Database class as introduced before in section <a href="#update">Update</a>.</p>
<h1 id="entity-inheritance">Entity Inheritance</h1>
<p>From a technical point of view, entity inheritance is of interest to encapsulate basic design concepts in a base class which should apply to various entity types in the same way. The chapter <a href="#find-and-query">Find and Query</a> already mentioned a few examples like a default public clone() method and a toString() method. Another typical reason is a stereotype set of table rows which should be present in each table like an auto-incremented technical ID, a creation time and a last modification time, or a lock counter for concurrency control by <a href="#optimistic-locking">optimistic locking</a>.</p>
<p>As a simple example for inheritance, you can split up the Customer entity in a way that the ID is encapsulated in a separate entity class IdentifiedEntity which the Customer entity is derived from. This is based on the assumption that all entity classes should have a unique ID row which is a wide-spread concept.</p>
<p>Inheritance in PriDE is a bit inconvenient as you have to maintain more than one inheritance hierarchy. However, new tables and entities don’t shoot like mushrooms out of the ground, so there’s no reason to bother. Beside the entities, you also have to relate both entities’ descriptors, and if you are working with separate adapters, the adapter classes have to be derived from each other too. As long as you are using 1:1 mappings, you can let PriDE’s entity generator do most of the job. So here is how to generate the little inheritance hierarchy which you can find in package <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/inheritance">inheritance</a> in the PriDE manual examples source code repository on <a href="https://github.com/j-pride/manual-example-code">GitHub</a>. You start with generating the base class. As the generator is based on table structures in a database and there is no such concept like “base classes” in SQL, you must ensure that the CUSTOMER table is already present (resp. any other table following the same pattern with a technical ID) . To generate a class which does not map all the columns, you specify the columns of interest as comma-separated list along with the table name when calling the generator:</p>
<pre><code>java
util.EntityGeneratorWithExampleConfig
CUSTOMER(ID) inherit.AbstractHybrid &gt; AbstractHybrid.java</code></pre>
<p>The call above uses the class EntityGeneratorWithExampleConfig mentioned at the end of the <a href="#quick-start-tutorial">Quick Start Tutorial</a> to simplify the passing of configuration parameters. Adding column names to a table name, tells the generator, that this is only a partial mapping resulting in an abstract class like this:</p>
<pre><code>abstract public class AbstractHybrid extends MappedObject implements Cloneable, java.io.Serializable {
    public static final String COL_ID = &quot;id&quot;;

    protected static final RecordDescriptor red =
      new RecordDescriptor(AbstractHybrid.class, null, null)
            .row( COL_ID, &quot;getId&quot;, &quot;setId&quot; );

    public RecordDescriptor getDescriptor() { return red; }

    private static String[] keyFields = new String[] { COL_ID };
    public String[] getKeyFields() { return keyFields; }

    private int id;

    public int getId()   { return id; }
    public void setId(int id) { this.id = id; }

    // Re-constructor
    public AbstractHybrid(int id) throws SQLException {
        setId(id);
        findx();
    }

    public AbstractHybrid() {}

    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

}</code></pre>
<p>Note that there was no table name constant generated and no table name is specified in the RecordDescriptor. All this doesn’t make sense for an abstract base class. The derived Customer class is then generated by specifying the base class in the generator call:</p>
<pre><code>java
util.EntityGeneratorWithExampleConfig
CUSTOMER inherit.DerivedCustomer
-h inherit.AbstractHybrid &gt; DerivedCustomer.java</code></pre>
<p>It is important to know that the call requires the base class to be compiled first. The generator will determine the remaining columns to map from reading the meta data of the CUSTOMER table from the database and the mapping information from the base class <em>as byte code</em>. It is therefore mandatory to specify the base class as fully qualified name even if it resides in the same package. The result looks like this:</p>
<pre><code>public class DerivedCustomer extends inherit.AbstractHybrid {
    public static final String TABLE = &quot;CUSTOMER&quot;;
    public static final String COL_NAME = &quot;name&quot;;
    public static final String COL_FIRST_NAME = &quot;first_name&quot;;

    protected static final RecordDescriptor red =
      new RecordDescriptor(DerivedCustomer.class, TABLE, inherit.AbstractHybrid.red)
        .row(COL_NAME, &quot;getName&quot;, &quot;setName&quot;)
        .row(COL_FIRST_NAME, &quot;getFirstName&quot;, &quot;setFirstName&quot;);

    public RecordDescriptor getDescriptor() { return red; }

    private static String[] keyFields = new String[] { COL_ID };
    public String[] getKeyFields() { return keyFields; }

    private String name;
    private String firstName;

    public String getName()   { return name; }
    public String getFirstName()   { return firstName; }

    public void setName(String name) { this.name = name; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    // Re-constructor
    public DerivedCustomer(int id) throws SQLException {
        super(id);
    }

    public DerivedCustomer() {}

}</code></pre>
<p>Note the following details:</p>
<ul>
<li>The class is not abstract and is derived from AbstractEntity</li>
<li>It contains only the attributes and corresponding getters and setters for the name and first name column.</li>
<li>The RecordDescriptor contains only mappings for these attributes and refers to the RecordDescriptor from the base class. The complete mapping for the CUSTOMER table is assembled from both descriptors.</li>
<li>The re-constructor doesn’t call the findx() method but the super re-constructor from AbstractEntity instead which already does the find job. The base class will consider <em>all</em> the mappings because the derived class overrides the methods getDescriptor() and getKeyFields().</li>
</ul>
<p>The resulting DerivedCustomer class behaves exactly like the Customer class from the <a href="#quick-start-tutorial">Quick Start Tutorial</a>. You can check that by running the <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/quickstart/CustomerClient.java">CustomerClient</a> from the quick start tutorial in parallel with the equivalent <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/inherit/DerivedCustomerClient.java">DerivedCustomerClient</a> from the package <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/inherit">inherit</a>. Both have the same functionality and operate on the same table but work with the two different entity representations. This reveals an important fact about PriDE’s concept how inheritance is mapped to SQL where you don’t find such a concept. In terms of JPA, PriDE follows the <a href="https://en.wikibooks.org/wiki/Java_Persistence/Inheritance#Example_table_per_class_inheritance_tables_in_database">table-per-class strategy</a>. For every non-abstract class in the hierarchy there must exist a database table with columns for <em>all</em> mapped attributes of the class itself and <em>all</em> its super classes.</p>
<h2 id="inheritance-with-separate-adapters">Inheritance with separate adapters</h2>
<p>When you are working with separate adapters, you need a derivation for both, entity class and adapter class. The generator calls look like that:</p>
<pre><code># Entity base class
java util.EntityGeneratorWithExampleConfig
CUSTOMER(id) inherit.AbstractEntity -b

# Adapter base class
java util.EntityGeneratorWithExampleConfig
CUSTOMER(id) inherit.AbstractAdapter inherit.AbstractEntity

# Derived Customer entity class
java util.EntityGeneratorWithExampleConfig
CUSTOMER inherit.DerivedCustomerEntity -b inherit.AbstractAdapter

# Derived Customer adapter class
java util.EntityGeneratorWithExampleConfig
CUSTOMER inherit.DerivedCustomerAdapter inherit.DerivedCustomerEntity inherit.AbstractAdapter</code></pre>
<p>An important detail is that generating the derived bean class requires to specify the base <em>adapter</em> class, not the base <em>entity</em> class in the generator call. In fact the generator needs to know about both, but the entity class can be determined from the adapter class’ record descriptor. The pure base entity class however doesn’t know about its mapping - that’s lastly the goal of the separation ;-)</p>
<p>The output of these generator calls is a very straight-forward separation of the hybrid code above. There is nothing tricky to know about. You can find the outcome in the package <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/inherit">inherit</a> from the PriDE manual examples source code repository on <a href="https://github.com/j-pride/manual-example-code">GitHub</a>.</p>
<p>Entity inheritance hierarchies are of course not limited in their depth. E.g. if it were a typical pattern that entities have names, try this command and have a look on the output:</p>
<pre><code>java util.EntityGeneratorWithExampleConfig
CUSTOMER(name) inherit.AbstractNamedHybrid -h inherit.AbstractHybrid</code></pre>
<p>What PriDE does not support are queries based on abstract base entities which automatically consider the tables of the derived non-abstract entities. You can find features like that in JPA, but they require a highly complicated, obscure SQL query assembly - in combination with the table-per-class strategy resulting in SQL union expressions. This is something, which doesn’t happen too often and should always remain in the developer’s responsibility to stay on control of your SQL.</p>
<h1 id="sql-expression-builder">SQL Expression Builder</h1>
<p>If you walked through the preceding chapters of this manual, you already came across some simple examples for building SQL expressions with PriDE’s expression builder. As this helpful little utility will be used more intensively in the following chapters, it is worth to understand its idea. It does not really depend on SQL but can be used for any string assembly where things become too confusing when making use of Java’s built-in capabilities like string concatenation, StringBuilder oder String.format(). Actually it is just a small extension of String.format().</p>
<h2 id="elaborated-sql-vs.-java">Elaborated SQL vs. Java</h2>
<p>Let’s take up the good old CUSTOMER table from the <a href="#quick-start-tutorial">Quick Start Tutorial</a> and let’s suppose you want to implement a batch application querying for suspicious new customer registrations, which the system will initially block from order placement until the customers have verified their identity (somehow). We are looking for customers in a certain ID range with</p>
<ul>
<li>The summarized length of name and first name is less than 7 letters or</li>
<li>The name consist only of a single letter or</li>
<li>Name and first name are identical</li>
</ul>
<p>SQL is a very powerful and highly expressive and compact language for things like that. The appropriate where-clause would look like that, where only the boundaries of the ID range differ from one call to the next:</p>
<pre><code>id between &lt;lowest&gt; and &lt;highest&gt; and (
    ( length(name) + length(first_name) &lt; 7 ) or
    ( length(name) &lt; 2 ) or
    ( name = first_name )
)</code></pre>
<p>No matter which assembly API your Java persistence manager provides - JPA’s criteria API, PriDE’s WhereCondition, or JOOQ’s DSL API - it will cost a lot more Java code than SQL code to assemble the expression, and it will become hard to tell from the Java code what the resulting SQL may look like. So the recommendation is: for the sake of SQL maintainability, integrate the SQL code in your Java code <em>as is</em>. Of course, Java won’t accept SQL syntax, so “integration as is” means integration as a String after having verified syntactical correctness in a suitable SQL tool. Unfortunately this would raise another maintenance problem: the String literal is a big, big <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)">magic number</a> composite and conflicts with the DRY principle. Although it contains various column name references you won’t be able to safely detect that the query might be affected e.g. when the NAME column requires a size change. You hopefully don’t try a full text search for the term “name” ;-)</p>
<p>As a first step towards a solution, PriDE’s entity generator generates constants for table and column names, and it is strongly recommended to use these columns for SQL expression assembly. However concatenating String fragments and constants won’t result in better readability:</p>
<pre><code>COL_ID + &quot; between &quot; + lowest + &quot; and &quot; + highest + &quot; and ( &quot; +
&quot;( length( + COL_NAME + &quot;) + length( &quot; + COL_FIRST_NAME + &quot;) &lt; 7 ) or&quot; +
...</code></pre>
<p>String.format() is designed to keep the structure of the result string recognizable, but in this case it won’t help too much:</p>
<pre><code>String.format(
&quot;%s between %d and %d and (&quot; +
&quot;    ( length(%s) + length(%s) &lt; 7 ) or&quot; +
&quot;    ( length(%4$s) &lt; 2 ) or&quot; +
&quot;    ( %4$s = %5$s )&quot; +
&quot;)&quot;,
COL_ID, lowest, highest, COL_NAME, COL_FIRST_NAME);</code></pre>
<h2 id="elaborated-sql-with-sqlexpressionbuilder">Elaborated SQL with SQLExpressionBuilder</h2>
<p>PriDE’s expression builder extends String.format() in a way, the you can use identifiers rather than just % and position numbers as variables. The builder is address by the static function <code>build(String formatString, Object... args)</code> in class pm.pride.SQL. Identifiers in the format string that require replacement by any of the following arguments begin with an @ character and end with the first character that is neither a letter nor an underscore. Based on that, the SQL can be represented almost natively:</p>
<pre><code>SQL.build(
&quot;@id between %d and %d and (&quot; +
&quot;    ( length(@name) + length(@first_name) &lt; 7 ) or&quot; +
&quot;    ( length(@name) &lt; 2 ) or&quot; +
&quot;    ( @name = @first_name )&quot; +
&quot;)&quot;,
COL_ID, lowest, highest, COL_NAME, COL_FIRST_NAME);</code></pre>
<p>As you can see, the identifier feature can be combined with Java’s standard replacement feature addressed by % characters. Arguments are assigned to identifiers in order of occurrence in the format string. Repeated occurrences of an identifier are replaced by the argument which was assigned to the identifier on its first occurrence.</p>
<p>By default, the identifiers and the assigned argument values don’t have to be identical, so the identifiers may be abbreviations or - vice versa - more descriptive forms of the actual table or column names passed as arguments. The possible risk is a hidden miss-assignment which still leads to syntactically valid SQL but to a wrong business logic. Referring to the example, swap the constants COL_NAME and COL_FIRST_NAME in the argument list and it results only in a minimal subtle miss behavior. If you don’t have fine-grained test suite to reveal such a bug, you may use the expression builder in a more restrictive way. If you call SQL.buildx() instead of SQL.build() the builder will throw an InvalidArgumentException if the variable identifiers don’t match the values of the assigned arguments based on a case-insensitive string comparison. E.g. the following SQL assembly would fail as the argument value “name” would be assigned to the variable identifier “first_name”:</p>
<pre><code>SQL.buildx(&quot;@first_name is null&quot;, &quot;name&quot;)</code></pre>
<p>This variant implies that you use the % notation where name conformity doesn’t make sense, e.g. for a column <em>value</em> instead of a column <em>name</em> like the ID range boundary values in the examples above. Additional validation options are available when you use the class SQLExpressionBuilder and its constructors directly. They allow to specify if the identifier comparison should be performed case sensitive or case insensitive and if the builder should actually throw an exception in case of miss-matches or just print out a warning on Stderr. Furthermore you may change the validation behavior of SQL.build() by setting SQLExpressionBuilder’s static member <code>validationDefault</code>.</p>
<p>If you need lots of arguments, it is helpful to split the argument list in multiple lines like the format string. Each argument line contains only the arguments which are (first) assigned to the identifiers of the corresponding line from the format string. Applied to the example above it looks like that:</p>
<pre><code>SQL.build(
&quot;@id between %d and %d and (&quot; +
&quot;    ( length(@name) + length(@first_name) &lt; 7 ) or&quot; +
&quot;    ( length(@name) &lt; 2 ) or&quot; +
&quot;    ( @name = @first_name )&quot; +
&quot;)&quot;,
COL_ID, lowest, highest,
COL_NAME, COL_FIRST_NAME);</code></pre>
<p>A small expression as the one above doesn’t need those tricks, but e.g. a complex SQL merge statement may require 20 arguments and more. Alternatively you may combine identifiers with position numbers as known from String.format(), so that you can check the identifier/argument matching by counting:</p>
<pre><code>SQL.build(
&quot;@1$id between %2$d and %3$d and (&quot; +
&quot;    ( length(@4$name) + length(@5$first_name) &lt; 7 ) or&quot; +
&quot;    ( length(@name) &lt; 2 ) or&quot; +
&quot;    ( @name = @first_name )&quot; +
&quot;)&quot;,
COL_ID, lowest, highest, COL_NAME, COL_FIRST_NAME);</code></pre>
<p>Only one occurrence of an identifier needs to be accompanied by a position specification, while all the others automatically inherit the argument assignment. You may add the position number to all occurrences but then they have to be identical. Re-positioning is not allowed.</p>
<h2 id="building-and-formatting">Building and Formatting</h2>
<p>All identifiers are replaced by the string representation of its assigned argument. The expression builder is <em>not</em> concerned with SQL value formatting. If you do not only pass column, table, and alias names as arguments but also <em>values</em>, you must ensure proper SQL formatting. There are different approaches to achieve that.</p>
<ul>
<li>Add formatting characters to the SQL string. This works well for simple data types like string and integer values, but you must be aware of the <a href="https://www.w3schools.com/sql/sql_injection.asp">SQL injection risk</a> if the values come from an untrustworthy source like a consumer website.</li>
<li>Format the value before passing it to the argument list. The value formatter for the current database is available through <code>DatabaseFactory.getDatabase().formatValue(Object value)</code>. The result is a fully formatted SQL value string. E.g. passing a string HELLO results in an SQL formatted String ‘HELLO’.</li>
<li>Just place a ? character in the SQL string and pass the value argument to the function that consumes the SQL rather than the builder. You can see an example at the end of chapter <a href="#find-and-query">Find and Query</a> in section <a href="#arbitrary-criteria">Arbitrary Criteria</a>.</li>
</ul>
<h1 id="joins">Joins</h1>
<p>PriDE provides different techniques to express joins, depending on the purpose resp. the type of outcome of the join:</p>
<ul>
<li>An entity being a 1:1 mapping of a table because the join is only required for complicated selection conditions that take related tables into account.</li>
<li>An extended entity consisting of a 1:1 mapping of a table, extended by a few attributes from a related table.</li>
<li>An entity composition, i.e. an entity for a 1:1 mapping of a table, extended by references to related entities that also represent 1:1 table mappings.</li>
<li>A composition from table fragments and/or computations, making up a new type of entity with its own specific meaning.</li>
</ul>
<p>The different variants are explained with the CUSTOMER table being used in all other examples so far, and an additional table ADDRESS like this:</p>
<pre><code>create table ADDRESS (
    customer_id integer not null,
    street varchar(30),
    city varchar(30)
);</code></pre>
<p>Each customer optionally has an address attached and the column customer_id is the foreign key to reference a customer from an address. You find a corresponding <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/joins/Address.java">Address entity</a> and a <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/joins/CreateAddressTable.java">table creation class</a> in the package <a href="https://github.com/j-pride/manual-example-code/tree/master/src/main/java/joins">joins</a> of PriDE’s manual examples source code repository on <a href="https://github.com/j-pride/manual-example-code">GitHub</a>.</p>
<p>Bringing customers and addresses together in a query requires a join which may look like that to express an inner join:</p>
<pre><code>select ... from
CUSTOMER cst
join ADDRESS addr
on addr.customer_id = cst.id </code></pre>
<p>Joins are combinations of tables and therefore require a descriptor like tables do. Although simple join cases can be expressed with the RecordDescriptor class explained in chapter <a href="#entity-adapter-and-descriptor">Entity, Adapter, and Descriptor</a>, you will usually work with the derived class <code>pm.pride.JoinRecordDescriptor</code>. All following examples make use of that class.</p>
<h2 id="joining-table-fragments">Joining Table Fragments</h2>
<p>Just because it gives the best view on how the join structure appears in PriDE code, let’s start with the most open variant: pulling fragments from different tables together, making up a new entity type. This is of interest when selecting huge amounts of records or when the result does not actually represent a primary entity like a customer or an address but is a kind of chimera. E.g. you may need a customer ID pair plus some address data in a query for duplicates, retrieving customers with same names and same addresses. To keep things simple for the beginning, this section’s example selects the ID and name from the CUSTOMER table and the city from the associated address. The pure entity part of this chimera looks like this:</p>
<pre><code>public class CustomerNameAndCity {
    private int id;
    private String name;
    private String city;

    // Standard getters and setters as usual
    // ...
}</code></pre>
<p>The entity generator cannot produce combined types, so you must assemble it by your own. However, the mechanical work is not really complicated and mature join conditions should remain in the developer’s responsibility anyway. You can make a hybrid entity from the type above by adding only a few details:</p>
<pre><code>public class CustomerNameAndCity extends MappedObject {
    // attributes, getters, and setters like above
    
    protected static final RecordDescriptor red;
    
    public RecordDescriptor getDescriptor() { return red; }
}</code></pre>
<p>You have seen this structure in many examples of this manual before. You may of course separate entity and adapter class as usual, but learning is easier with hybrid types. The essential detail is the assembly of the record descriptor. Using PriDE’s JoinRecordDescriptor type, the join is assembled as follows</p>
<pre><code>protected static final RecordDescriptor red =
    new JoinRecordDescriptor(CustomerNameAndCity.class,
&quot;CUSTOMER&quot;, &quot;cst&quot;)
.join(&quot;ADDRESS&quot;, &quot;addr&quot;,
&quot;addr.customer_id = cst.id&quot;)</code></pre>
<p>The funny line indention above is just there to point out that all the parts of an SQL join are plain to see in the core of the descriptor definition. Compare that to the join at the beginning of this chapter. What needs to be added is the mapping of table columns to attributes. This is accomplished by the row() method which you already know from earlier descriptor examples. You have to add them after each part describing a table. So for the name and city example the complete descriptor looks like that:</p>
<pre><code>protected static final RecordDescriptor red =
  new JoinRecordDescriptor
    (CustomerNameAndCity.class, &quot;CUSTOMER&quot;, &quot;cst&quot;)
          .row(&quot;id&quot;, &quot;getId&quot;, &quot;setId&quot;)
          .row(&quot;name&quot;, &quot;getName&quot;, &quot;setName&quot;)
      .join(&quot;ADDRESS&quot;, &quot;addr&quot;, &quot;addr.customer_id = cst.id&quot;)
          .row(&quot;city&quot;, &quot;getCity&quot;, &quot;setCity&quot;);</code></pre>
<p>Of course it is strongly recommended to substitute the string literal by references to appropriate constants. Usually you should have the (generated) primary entity types for CUSTOMER and ADDRESS available, including constants for tables and columns. Constants for the alias names “cst” and “addr” must be added by the developer, and the join condition should be assembles with the <a href="#sql-expression-builder">SQL expression builder</a>. For the example above the clean-up results in something like that:</p>
<pre><code>public static final String CUSTOMER_ALIAS = &quot;cst&quot;;
public static final String ADDRESS_ALIAS = &quot;addr&quot;;
public static final String CUSTOMER_ADDRESS_JOIN_CONDITION =
  SQL.build(&quot;@addr.@customer_id = @cst.@id&quot;,
    ADDRESS_ALIAS, Address.COL_CUSTOMER_ID,
    CUSTOMER_ALIAS, Customer.COL_ID);

protected static final RecordDescriptor red =
  new JoinRecordDescriptor(
    CustomerNameAndCity.class,
    Customer.TABLE,
    CUSTOMER_ALIAS)
        .row(Customer.COL_ID, &quot;getId&quot;, &quot;setId&quot;)
        .row(Customer.COL_NAME, &quot;getName&quot;, &quot;setName&quot;)
    .join(
      Address.TABLE,
      ADDRESS_ALIAS,
      CUSTOMER_ADDRESS_JOIN_CONDITION)
        .row(Address.COL_CITY, &quot;getCity&quot;, &quot;setCity&quot;);</code></pre>
<p>At the first sight this may look less clear than the example based on string literals. However, the price you pay for the constant-based form is usually worth it when your application grows. Joins are a very powerful concept from SQL but may violate module boundaries in a vertically well-structured Java architecture. if you allow the violation for powerful joins you should at least make the module dependencies trackable by using constants across the boundaries. If you change something in any of the tables and their corresponding primary entity mappings, the depending join descriptors and joined entity types should automatically change as well or lead the developer to broken code through compile time errors. Hidden dependencies by intense use of magic numbers compromises refactoring of the application code, and sophisticated persistence operations should not be an excuse.</p>
<p>If you want to perform a left outer rather than an inner join, you have to exchange the call of method join() by a call of leftJoin(). A typical problem when designing outer join types is the fact that all data from the joined tables is <em>optional</em> data. The corresponding attributes which this data is mapped to, must therefore accept null values. I.e. primitive attributes types like <code>int</code> or <code>long</code> are not suitable.</p>
<p>The complete hybrid entity type <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/joins/CustomerNameAndCity.java">CustomerNameAndCity</a> (based on constants) can be found in PriDE’s manual examples source code repository on <a href="https://github.com/j-pride/manual-example-code">GitHub</a>.</p>
<h2 id="joining-entities-with-fragments">Joining Entities with Fragments</h2>
<p>Another typical join variant is to extend the complete content of a record from one table by fragments from other associated tables. Applied to the customer/address example, something like that for a full customer and the city from the associated address:</p>
<pre><code>select cst.*, addr.city from
CUSTOMER cst
join ADDRESS addr
on addr.customer_id = cst.id </code></pre>
<p>The term “extend” already leads to the technical solution: create a new type derived from the Customer class which contains the attribute <em>city</em> and appropriate mappings. You can use a different constructor for JoinRecordDescriptor here which refers to the base class’ descriptor to minimize the additional descriptive work to do.</p>
<pre><code>public class CustomerWithCity extends Customer {

  protected static final RecordDescriptor red =
    new JoinRecordDescriptor(
        CustomerWithCity.class,
        Customer.red,
        CUSTOMER_ALIAS)
      .join(
        Address.TABLE,
        ADDRESS_ALIAS,
        CUSTOMER_ADDRESS_JOIN_CONDITION)
      .row(Address.COL_CITY, &quot;getCity&quot;, &quot;setCity&quot;);

    public RecordDescriptor getDescriptor() { return red; }

    private String city;

    public String getCity() { return city; }
    public void setCity(String city) { this.city = city; }
}</code></pre>
<p>The complete class <a href="https://github.com/j-pride/manual-example-code/blob/master/src/main/java/joins/CustomerWithCity.java">CustomerWithCity</a> can be found in PriDE’s manual examples source code repository on <a href="https://github.com/j-pride/manual-example-code">GitHub</a>. It uses the same join condition and table aliases as the example from section <a href="#joining-table-fragments">Joining Table Fragments</a>. Writing queries for such a class may require to put the table alias in front of column names if the same name appears in more than one of the joined tables. As long as the names are unique, you can work with plain column names. E.g. customers living in London can be found by</p>
<pre><code>CustomerWithCity cwc = new CustomerWithCity();
cwc.setCity(&quot;London&quot;);
cwc.queryByExample(COL_CITY);</code></pre>
<p>If the extended type inherits query methods from the base class, you can still use all methods that don’t refer to columns which became ambiguous by the extension. E.g. CustomerWithCity can be equipped by a re-constructor that delegates to the Customer class’ re-constructor:</p>
<pre><code>public CustomerWithCity(int id) throws SQLException {
    super(id);
}</code></pre>
<h2 id="entity-composition">Entity Composition</h2>
<p>A very simple join case is a complete composition of existing entities. This variant requires to derive a composite type from one entity type with members for the associated entity types. For a customer and its address, such a join may look like this:</p>
<pre><code>public class CustomerWithAddress extends Customer {
    Address address;

    public Address getAddress() { return address; }
    public void setAddress(Address a) { this.address = a; }

    public static RecordDescriptor red =
      new JoinRecordDescriptor(Customer.red, CUSTOMER_ALIAS)
        .join(Address.red, ADDRESS_ALIAS,
            &quot;address&quot;, CUSTOMER_ADDRESS_JOIN_CONDITION);
            
    public RecordDescriptor getDescriptor() { return red; }
}</code></pre>
<p>The example above makes use of a join() method that gets passed the descriptor for the contained entity and the name of the member. PriDE will not access the member directly but use the appropriate getter and setter method. Why using the setter? Well, here is the only exception to the rule that PriDE doesn’t create entities. If a contained entity is null when being required to receive data from the database, PriDE will create an instance and associate it to the composite type by calling the appropriate setter. The contained entity type must provide a constructor without parameters or a constructor getting passed the containing entity.</p>
<p>As mentioned earlier, you may change from inner to left outer join by calling leftJoin() rather than join() in the descriptor assembly. When iterating through the results, PriDE will set the member to null for every record which has no joined record associated and re-create the member when needed.</p>
<h2 id="ad-hoc-joins">Ad-hoc Joins</h2>
<p>Sometimes a join is only needed to express query conditions which span multiple related tables but the results are entities of a type which is already present. For these cases, it is not desirable to create a new entity type just to provide a place for the join descriptor. As an alternative a record descriptor may be defined where ever an when ever and passed to special query methods provided by every hybrid entity and every adapter class.</p>
<p>Let’s come back to the example of retrieving customers living in London but without actually selecting any address data. The following code snippet demonstrates an example:</p>
<pre><code>Customer c = new Customer();

RecordDescriptor customerJoinedWithAddress =
  new JoinRecordDescriptor(c.getDescriptor(), CUSTOMER_ALIAS)
    .join(Address.TABLE, ADDRESS_ALIAS,
          CUSTOMER_ADDRESS_JOIN_CONDITION);

WhereCondition onlyLondon =
  new WhereCondition().and(&quot;city&quot;, &quot;London&quot;);
  
c.joinQuery(customerJoinedWithAddress, onlyLondon);</code></pre>
<p>The method joinQuery() accepts every record descriptor which is compatible with the entity’s own descriptor in the sense that it maps to the same entity type.</p>
<p>You have seen a lot of different ways now to express table joins in PriDE. Finally it is important to mentioned that the class JoinRecordDescriptor is not restricted in the number of tables to join. You may chain the calls of join() and leftJoin() as ofter as needed. So happy joining :-)</p>
				</div>
			</section>

			<script src="https://j-pride.github.io/assets/js/jquery.min.js"></script>
			<script src="https://j-pride.github.io/assets/js/skel.min.js"></script>
			<script src="https://j-pride.github.io/assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="https://j-pride.github.io/assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="https://j-pride.github.io/assets/js/main.js"></script>
</body>
</html>
