<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Entity, Adapter, and Descriptor</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../assets/css/main.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
		<div class="subpage-menu">
			<a href="http://pride.pm"><i class="fa fa-home"></i> Home</a>
		</div>
		<section id="three" class="wrapper">
			<div class="inner">
<header id="title-block-header">
<h1 class="title">Entity, Adapter, and Descriptor</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#descriptor-structure">Descriptor structure</a></li>
<li><a href="#attribute-type-mapping">Attribute Type Mapping</a></li>
</ul>
</nav>
<p>The concept of O/R mapping requires three basic building blocks:</p>
<ul>
<li>Entity classes which representing data in SQL tables - in the most common usage one entity object represents one record in one SQL table</li>
<li>Descriptors, describing how the entity classes map to the database</li>
<li>An adapter which reads data from the database to entities (select) and writes data from entities to the database (insert, update, delete)</li>
</ul>
<p>There are very different approaches around how to express the descriptor. JPA uses annotations on entity classes, MyBatis uses XML files, and PriDE follows a different approach as you may have seen already from the <a href="quick-start-tutorial.html">quick start tutorial</a>. The descriptor is an instance of class pm.pride.RecordDescriptor, i.e. it is code itself. This concept has a few advantages over other approaches.</p>
<ul>
<li>It does not clutter the entity classes with database details, so entities can be passed around in the application without violating the information hiding principle. If you are familiar with JPA you may have experienced the problem that mapping annotations can pile up to an annoying amount.</li>
<li>Its not written in a different language which is always hard to keep in sync with the Java code. This becomes a serious problem when applications grow over time. If you are only working with three database tables, you won’t have this problem, of course.</li>
<li>If it is Java code, it can be tied to any other related Java code by using shared constants for table named and row names and so on. This allows you to easily keep track of dependencies in the code. E.g. if you remove a column from a database table you will remove the appropriate constant in the code and every mentionable IDE will immediately lead you to all the places in the code that do not compile any more. This will include the descriptor as well as all the database queries in the code that refer to that column.</li>
<li>Descriptors may also be assembled dynamically at runtime. You hopefully will not often run into situations where you need that, but its good to know that there is no limit on that.</li>
</ul>
<p>A coded descriptor needs to go somewhere in your code, of course. PriDE provides two default patterns for the descriptor placement which are obvious when you think of the building blocks mentioned above: descriptors within adapter classes or descriptors within entity classes.</p>
<p>Descriptors in entities is what you know already from the <a href="quick-start-tutorial.html">quick start tutorial</a>. It cases the entities to become their own adapters having their own persistence methods. This is a compact pattern which is suitable for small applications. Therefore you will find it spread over most examples provided with PriDE. The disadvantage is the same one mentioned above with JPA: the entity classes spread knowledge about database mapping information all over the code. Combined with persistence capabilities directly incorporated in entity classes, this is a questionable concept in bigger architectures.</p>
<p>Let’s have a look on the more sophisticated pattern of separate adapter classes. You can have a look on the general structure by generating separate classes for the quick start example table. The pure entity class can be generated by the following command:</p>
<pre><code>java
-D... see quick start tutorial
pm.pride.util.generator.EntityGenerator CUSTOMER adapter.CustomerEntity -b &gt; CustomerEntity.java</code></pre>
<p>The parameter -b tells the generator to create only an entity class without descriptor. The result is an ordinary Java bean or POJO class:</p>
<pre><code>package adapter;

public class CustomerEntity implements Cloneable, java.io.Serializable {
    private long id;
    private String name;
    private String firstName;

    public long getId()   { return id; }
    public String getName()   { return name; }
    public String getFirstName()   { return firstName; }

    public void setId(long id) { this.id = id; }
    public void setName(String name) { this.name = name; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    // re-constructor
    public CustomerEntity(long id) {
        setId(id);
    }

    public CustomerEntity() {}
}</code></pre>
<p>The “re-constructor” is an additional constructor getting passed a value for all the attributes making up the entity’s primary key. This of interest for find operations.</p>
<p>Generating the corresponding adapter class looks like this:</p>
<pre><code>java
-D... see quick start tutorial
pm.pride.util.generator.EntityGenerator CUSTOMER adapter.CustomerAdapter adapter.CustomerEntity &gt; CustomerAdapter.java</code></pre>
<p>The first parameter after the table name specifies the class to generate - in this case a class called CustomerAdapter in package adapter. The second parameter is the name of a entity class the adapter should refer to. The result looks like this:</p>
<pre><code>package adapter;

public class CustomerAdapter extends ObjectAdapter {
    public static final String TABLE = &quot;CUSTOMER&quot;;
    public static final String COL_ID = &quot;id&quot;;
    public static final String COL_NAME = &quot;name&quot;;
    public static final String COL_FIRST_NAME = &quot;first_name&quot;;

    protected static final RecordDescriptor red =
      new RecordDescriptor(CustomerEntity.class, TABLE, null)
        .row(COL_ID, &quot;getId&quot;, &quot;setId&quot;)
        .row(COL_NAME, &quot;getName&quot;, &quot;setName&quot;)
        .row(COL_FIRST_NAME, &quot;getFirstName&quot;, &quot;setFirstName&quot;)
        .key(COL_ID);

    public RecordDescriptor getDescriptor() { return red; }

    CustomerAdapter(CustomerEntity entity) { super(entity); }
}</code></pre>
<p>All what the adapter class has to provide is a RecordDescriptor and an optional list of column names making up the entity’s primary key. Based on that, the class inherits all entity-related persistence capabilities from class pm.pride.ObjectAdapter. Adapters always operate on an instance of the entity class which must be passed in the adapter’s constructor. Finding a customer by its primary ID looks like this when using separate adapter classes:</p>
<pre><code>// Create a customer entity, initialized with a primary key value of 1
CustomerEntity customer = new CustomerEntity(1);

// Create an adapter based on the entity
CustomerAdapter adapter = new CustomerAdapter(customer);

// Call the adapter&#39;s find method to find a customer by primary key 1.
// The primary key value is read from the entity passed in the adapter&#39;s constructor
// The result (if any) is written to the same entity
adapter.find();</code></pre>
<p>As you see, every persistence operation now requires one additional line of code to create the adapter. Especially when you design a multi-threaded application, it is important to know that adapter and entity instances are not supposed to be shared among multiple threads. So creating new instances in every operation is the prefered technique and is usually not a considerable code complication.</p>
<p>If you want to minimize the amount of code, you are free to invent your own adapter concept. Have a look on the base classes pm.pride.ObjectAdapter for the adapter above and pm.pride.MappedObject for the hybrid variant from the <a href="quick-start-tutorial.html">quick start tutorial</a>. Both are minimalistic implementations of the mix-in pm.pride.DatabaseAdapterMixin which is the actual provider for all entity-related persistence operations. It is in turn based on the static methods of the class pm.pride.DatabaseAdapter. Using this class or the mix-in you could easily produce a generic adapter being responsible for multiple entity types similar to JPA’s EntityManager interface.</p>
<p>One note concerning packages: When you actually use the pattern of separate adapters in a sophisticated architecture, you should consider generating entity and adapter classes in different packages. Only the entity classes should be part of the interface for dependent code while the adapter classes should completely be hidden behind facade components as proposed in the wide-spread <a href="https://martinfowler.com/eaaCatalog/repository.html">repository pattern</a>.</p>
<h2 id="descriptor-structure">Descriptor structure</h2>
<p>The examples for descriptors you have seen so far should already clarify most of the descriptor structure. You will see more complicated examples in following chapters of this manual. A descriptor is assembled from the following information:</p>
<ul>
<li><p>The name of the entity class and the name of the database table which the entity class is mapped to. Preferably the table name is not specified as a string-literal but as a reference to a constant representing the table name. If you have a look on the outcome of PriDE’s code generator, there are appropriate constants generated and used.</p></li>
<li><p>A reference to the descriptor of a base class. This is of interest when you build up an inheritance hierarchy between entity classes as explained in chapter <a href="entity-inheritance.html">Entity Inheritance</a>.</p></li>
<li><p>A table-row to attribute mapping by adding calls of the row() method for every row of interest. The row() method returns the descriptor object, making up a fluent API. Every row/attribute mapping consists of</p>
<ul>
<li>The name of the database column (similar to table names: avoid using string-literals here)</li>
<li>The name of the getter method for the corresponding attribute in the entity class</li>
<li>The name of the setter method</li>
</ul>
<p>The methods are the ones which the adapter is supposed to use for transporting entity attributes to the database via JDBC and vice versa. The getter methods’ return type implies which methods the adapter uses to access JDBC statements and result sets and how to translate the values to SQL syntax. Getters are mandatory whereas setters may be null in case of entity types that are never supposed to be written to the database. A typical example for this case are entity classes representing the result of SQL joins (see chapter <a href="joins.html">Joins</a>).</p></li>
<li><p>An optional primary key definition by adding a call of the key() method with a list of column names making up the primary key. Alternatively you can use rowPK() instead of row() for the row mappings.</p></li>
</ul>
<p>The RecordDescriptor class has a few more constructors concerned with joins and <a href="multiple-databases.html">accessing multiple databases</a>, but that’s not important for now. The basic structure described above is what you work with most of the time.</p>
<h2 id="attribute-type-mapping">Attribute Type Mapping</h2>
<p>The following table illustrates the mapping of Java object attribute types to SQL database field types as they are supported by PriDE. The row <em>‘JDBC type’</em> determines the type being used for the specified attribute type to access results from a JDBC ResultSet or to pass inputs to a JDBC PreparedStatement. The <em>‘SQL type’</em> specifies the actual SQL row types, the attributes can usually be mapped to. Not all SQL databases support all the mentioned type identifiers and it may also depend on the JDBC driver’s capabilities which mappings are supported. Primitive attribute types should of course only be used, if the corresponding row must not be NULL. Otherwise an exception will be thrown at runtime when attempting to process NULL values.</p>
<table>
<thead>
<tr class="header">
<th><strong>Java attribute type</strong></th>
<th><strong>JDBC type</strong></th>
<th><strong>SQL type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>String</td>
<td>String</td>
<td>VARCHAR, VARCHAR2, NVARCHAR2, CHAR</td>
</tr>
<tr class="even">
<td>java.util.Date</td>
<td>java.sql.Date</td>
<td>DATE, DATETIME, TIMESTAMP, TIME</td>
</tr>
<tr class="odd">
<td>java.sql.Date</td>
<td>java.sql.Date</td>
<td>DATE, DATETIME, TIMESTAMP, TIME</td>
</tr>
<tr class="even">
<td>java.sql.Timestamp</td>
<td>java.sql.Timestamp</td>
<td>DATETIME, TIMESTAMP, TIME</td>
</tr>
<tr class="odd">
<td>int / Integer</td>
<td>Integer</td>
<td>INTEGER</td>
</tr>
<tr class="even">
<td>float / Float</td>
<td>Float</td>
<td>DECIMAL, REAL</td>
</tr>
<tr class="odd">
<td>double / Double</td>
<td>Double</td>
<td>DECIMAL, REAL</td>
</tr>
<tr class="even">
<td>Any enum</td>
<td>String</td>
<td>VARCHAR, VARCHAR2, NVARCHAR2, CHAR</td>
</tr>
<tr class="odd">
<td>boolean / Boolean</td>
<td>Boolean</td>
<td>BOOLEAN, INTEGER, SMALLINT, TINYINT, CHAR</td>
</tr>
<tr class="even">
<td>BigDecimal</td>
<td>BigDecimal</td>
<td>DECIMAL, NUMBER</td>
</tr>
<tr class="odd">
<td>long / Long</td>
<td>Long</td>
<td>INTEGER, DECIMAL, NUMBER, BIGINT</td>
</tr>
<tr class="even">
<td>short / Short</td>
<td>Short</td>
<td>INTEGER, SMALLINT, TINYINT, DECIMAL</td>
</tr>
<tr class="odd">
<td>byte / Byte</td>
<td>Byte</td>
<td>TINYINT</td>
</tr>
<tr class="even">
<td>byte[]</td>
<td>byte[]</td>
<td>BLOB, LONGVARBINARY, VARBINARY</td>
</tr>
<tr class="odd">
<td>java.sql.Blob</td>
<td>java.sql.Blob</td>
<td>BLOB, LONGVARBINARY, VARBINARY</td>
</tr>
<tr class="even">
<td>java.sql.Clob</td>
<td>java.sql.Clob</td>
<td>CLOB, LONGVARCHAR</td>
</tr>
<tr class="odd">
<td>java.sql.SQLXML / String</td>
<td>java.sql.SQLXML</td>
<td>java.sql.SQLXML</td>
</tr>
</tbody>
</table>
<p>Clobs and Blobs can only be used through PreparedStatements, i.e. you either have to access the entities with Clob / Blob attributes with PriDE’s <a href="prepared-operations.html">prepared operations</a> or you configure PriDE to use bind variables by default (see <a href="quick-start-tutorial.html">quick start tutorial</a>).</p>
<p>The precision of dates and time stamps in the database vary significantly between different database vendors. E.g. although date rows were originally intended to represent dates without time portions in SQL databases, Oracle allows seconds precision instead and so does PriDE for Oracle. When using PriDE with plain SQL, dates and timestamps are rendered by appropriate database-specific formating functions like <code>to_date</code> or <code>to_timestamp</code> in Oracle, preserving the same precision as it applies to prepared statements.</p>
<p>The interface <code>pm.pride.ResourceAccessor</code> provides the constant <em>SYSTIME_DEFAULT</em>. In update and insert operations this values will be translated to an expression which addresses the current database server time like <em>CURRENT_TIMESTAMP</em> in MySQL or <em>SYSDATE</em> in Oracle. This translation is only applied in plain SQL.</p>
<p>You can tell PriDE to map a java.util.Date attribute to an SQL time stamp by providing the JDBC type in the row definition of the record descriptor as an additional parameter like that:</p>
<pre><code>.row(&lt;columnname&gt;, &lt;getter&gt;, &lt;setter&gt;, java.sql.Timestamp.class)</code></pre>
<p>There are a few more type conversions which can be expressed that way. E.g. Enums can be represented by their ordinals in the database by providing <code>java.lang.Integer.class</code> as additional parameter for the mapping of the corresponding attributes.</p>
<p>The general pattern for arbitrary type conversion is to provide appropriate additional getter/setter pairs which encapsulate the conversion. To make clear, that these getters / setters are for internal use only, it is common practice to give the method names a leading underscore. Assume you have an enumeration type for coins with their value in cent like that:</p>
<pre><code>public enum Coin {
    FIVE_CENT(5), FIFTY_CENT(50), ONE_EURO(100);
    
    private int valueInCent;
    Coin(int valueInCent) { this.valueInCent = valueInCent; }
    int value() { return valueInCent; }
}</code></pre>
<p>If you map an attribute of this type to the database, PriDE expects an SQL row of type VARCHAR or a similar type to store values like ‘FIVE_CENT’ etc. If you want to represent the coins by their value in the database, you provide a type-converting getter-setter-pair for the corresponding attribute in the entity class:</p>
<pre><code>class MyEntity {
    private Coin myAttr;
    
    public int _getMyAttr() {
        return myAttr.value();
    }
    
    public void _setMyAttr(int v) {
        for (Coin coin: Coin.values()) {
            if (coin.value() == v) {
                myAttr = coin;
                return;
            }
        }
        throw new IllegalArgumentException();
    }
}</code></pre>
<p>Now you can use this getter setter pair to map the myAttr attribute to a DECIMAL table row, holding the coins’ values:</p>
<pre><code>.row(&quot;MYATTR&quot;, &quot;_getMyAttr&quot;, &quot;_setMyCoin&quot;)</code></pre>
<div class="subpage-navigation">
<p>
<a id="prev" href="quick-start-tutorial.html"> Prev.</a> | <a id="next" href="find-and-query.html">Next </a>
</p>
</div>
				</div>
			</section>

			<script src="https://j-pride.github.io/assets/js/jquery.min.js"></script>
			<script src="https://j-pride.github.io/assets/js/skel.min.js"></script>
			<script src="https://j-pride.github.io/assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="https://j-pride.github.io/assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="https://j-pride.github.io/assets/js/main.js"></script>
</body>
</html>
