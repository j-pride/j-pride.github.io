<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Entity, Adapter, and Descriptor</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../assets/css/main.css" />
</head>
<body>
		<div class="subpage-menu">
			<a href="http://pride.pm"><i class="fa fa-home"></i> Home</a>
		</div>
		<section id="three" class="wrapper">
			<div class="inner">
<header id="title-block-header">
<h1 class="title">Entity, Adapter, and Descriptor</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#descriptor-structure"
id="toc-descriptor-structure">Descriptor structure</a></li>
<li><a href="#attribute-type-mapping"
id="toc-attribute-type-mapping">Attribute Type Mapping</a></li>
</ul>
</nav>
<p>The concept of O/R mapping requires three basic building blocks:</p>
<ul>
<li>Entity classes which representing data in SQL tables - in the most
common usage one entity object represents one record in one SQL
table</li>
<li>Descriptors, describing how the entity classes map to the
database</li>
<li>An adapter which reads data from the database to entities (select)
and writes data from entities to the database (insert, update,
delete)</li>
</ul>
<p>There are very different approaches around how to express the
descriptor. JPA uses annotations on entity classes, MyBatis uses XML
files, and PriDE follows a different approach as you may have seen
already from the <a href="quick-start-tutorial.html">quick start
tutorial</a>. The descriptor is an instance of class
pm.pride.RecordDescriptor, i.e. it is code itself. This concept has a
few advantages over other approaches.</p>
<ul>
<li>It does not clutter the entity classes with database details, so
entities can be passed around in the application without violating the
information hiding principle. If you are familiar with JPA you may have
experienced the problem that mapping annotations can pile up to an
annoying amount.</li>
<li>Its not written in a different language which is always hard to keep
in sync with the Java code. This becomes a serious problem when
applications grow over time. If you are only working with three database
tables, you won’t have this problem, of course.</li>
<li>If it is Java code, it can be tied to any other related Java code by
using shared constants for table named and row names and so on. This
allows you to easily keep track of dependencies in the code. E.g. if you
remove a column from a database table you will remove the appropriate
constant in the code and every mentionable IDE will immediately lead you
to all the places in the code that do not compile any more. This will
include the descriptor as well as all the database queries in the code
that refer to that column.</li>
<li>Descriptors may also be assembled dynamically at runtime. You
hopefully will not often run into situations where you need that, but
its good to know that there is no limit on that.</li>
</ul>
<p>A coded descriptor needs to go somewhere in your code, of course.
PriDE provides two default patterns for the descriptor placement which
are obvious when you think of the building blocks mentioned above:
descriptors within adapter classes or descriptors within entity
classes.</p>
<p>Descriptors in entities is what you know already from the <a
href="quick-start-tutorial.html">quick start tutorial</a>. It cases the
entities to become their own adapters having their own persistence
methods. This is a compact pattern which is suitable for small
applications. Therefore you will find it spread over most examples
provided with PriDE. The disadvantage is the same one mentioned above
with JPA: the entity classes spread knowledge about database mapping
information all over the code. Combined with persistence capabilities
directly incorporated in entity classes, this is a questionable concept
in bigger architectures.</p>
<p>Let’s have a look on the more sophisticated pattern of separate
adapter classes. You can have a look on the general structure by
generating separate classes for the quick start example table. The pure
entity class can be generated by the following command:</p>
<pre><code>java
-D... see quick start tutorial
pm.pride.util.generator.EntityGenerator CUSTOMER adapter.CustomerEntity -b &gt; CustomerEntity.java</code></pre>
<p>The parameter -b tells the generator to create only an entity class
without descriptor. The result is an ordinary Java bean or POJO
class:</p>
<pre><code>package adapter;

public class CustomerEntity implements Cloneable, java.io.Serializable {
    private long id;
    private String name;
    private String firstName;

    public long getId()   { return id; }
    public String getName()   { return name; }
    public String getFirstName()   { return firstName; }

    public void setId(long id) { this.id = id; }
    public void setName(String name) { this.name = name; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    // re-constructor
    public CustomerEntity(long id) {
        setId(id);
    }

    public CustomerEntity() {}
}</code></pre>
<p>The “re-constructor” is an additional constructor getting passed a
value for all the attributes making up the entity’s primary key. This of
interest for find operations.</p>
<p>Generating the corresponding adapter class looks like this:</p>
<pre><code>java
-D... see quick start tutorial
pm.pride.util.generator.EntityGenerator CUSTOMER adapter.CustomerAdapter adapter.CustomerEntity &gt; CustomerAdapter.java</code></pre>
<p>The first parameter after the table name specifies the class to
generate - in this case a class called CustomerAdapter in package
adapter. The second parameter is the name of a entity class the adapter
should refer to. The result looks like this:</p>
<pre><code>package adapter;

public class CustomerAdapter extends ObjectAdapter {
    public static final String TABLE = &quot;CUSTOMER&quot;;
    public static final String COL_ID = &quot;id&quot;;
    public static final String COL_NAME = &quot;name&quot;;
    public static final String COL_FIRST_NAME = &quot;first_name&quot;;

    protected static final RecordDescriptor red =
      new RecordDescriptor(CustomerEntity.class, TABLE, null)
        .row(COL_ID, &quot;getId&quot;, &quot;setId&quot;)
        .row(COL_NAME, &quot;getName&quot;, &quot;setName&quot;)
        .row(COL_FIRST_NAME, &quot;getFirstName&quot;, &quot;setFirstName&quot;)
        .key(COL_ID);

    public RecordDescriptor getDescriptor() { return red; }

    CustomerAdapter(CustomerEntity entity) { super(entity); }
}</code></pre>
<p>All what the adapter class has to provide is a RecordDescriptor and
an optional list of column names making up the entity’s primary key.
Based on that, the class inherits all entity-related persistence
capabilities from class pm.pride.ObjectAdapter. Adapters always operate
on an instance of the entity class which must be passed in the adapter’s
constructor. Finding a customer by its primary ID looks like this when
using separate adapter classes:</p>
<pre><code>// Create a customer entity, initialized with a primary key value of 1
CustomerEntity customer = new CustomerEntity(1);

// Create an adapter based on the entity
CustomerAdapter adapter = new CustomerAdapter(customer);

// Call the adapter&#39;s find method to find a customer by primary key 1.
// The primary key value is read from the entity passed in the adapter&#39;s constructor
// The result (if any) is written to the same entity
adapter.find();</code></pre>
<p>As you see, every persistence operation now requires one additional
line of code to create the adapter. Especially when you design a
multi-threaded application, it is important to know that adapter and
entity instances are not supposed to be shared among multiple threads.
So creating new instances in every operation is the prefered technique
and is usually not a considerable code complication.</p>
<p>If you want to minimize the amount of code, you are free to invent
your own adapter concept. Have a look on the base classes
pm.pride.ObjectAdapter for the adapter above and pm.pride.MappedObject
for the hybrid variant from the <a
href="quick-start-tutorial.html">quick start tutorial</a>. Both are
minimalistic implementations of the mix-in pm.pride.DatabaseAdapterMixin
which is the actual provider for all entity-related persistence
operations. It is in turn based on the static methods of the class
pm.pride.DatabaseAdapter. Using this class or the mix-in you could
easily produce a generic adapter being responsible for multiple entity
types similar to JPA’s EntityManager interface.</p>
<p>One note concerning packages: When you actually use the pattern of
separate adapters in a sophisticated architecture, you should consider
generating entity and adapter classes in different packages. Only the
entity classes should be part of the interface for dependent code while
the adapter classes should completely be hidden behind facade components
as proposed in the wide-spread <a
href="https://martinfowler.com/eaaCatalog/repository.html">repository
pattern</a>.</p>
<h2 id="descriptor-structure">Descriptor structure</h2>
<p>The examples for descriptors you have seen so far should already
clarify most of the descriptor structure. You will see more complicated
examples in following chapters of this manual. A descriptor is assembled
from the following information:</p>
<ul>
<li><p>The name of the entity class and the name of the database table
which the entity class is mapped to. Preferably the table name is not
specified as a string-literal but as a reference to a constant
representing the table name. If you have a look on the outcome of
PriDE’s code generator, there are appropriate constants generated and
used.</p></li>
<li><p>A reference to the descriptor of a base class. This is of
interest when you build up an inheritance hierarchy between entity
classes as explained in chapter <a href="entity-inheritance.html">Entity
Inheritance</a>.</p></li>
<li><p>A table-row to attribute mapping by adding calls of the row()
method for every row of interest. The row() method returns the
descriptor object, making up a fluent API. Every row/attribute mapping
consists of</p>
<ul>
<li>The name of the database column (similar to table names: avoid using
string-literals here)</li>
<li>The name of the getter method for the corresponding attribute in the
entity class</li>
<li>The name of the setter method</li>
</ul>
<p>The methods are the ones which the adapter is supposed to use for
transporting entity attributes to the database via JDBC and vice versa.
The getter methods’ return type implies which methods the adapter uses
to access JDBC statements and result sets and how to translate the
values to SQL syntax. Getters are mandatory whereas setters may be null
in case of entity types that are never supposed to be written to the
database. A typical example for this case are entity classes
representing the result of SQL joins (see chapter <a
href="joins.html">Joins</a>).</p></li>
<li><p>An optional primary key definition by adding a call of the key()
method with a list of column names making up the primary key.
Alternatively you can use rowPK() instead of row() for the row
mappings.</p></li>
</ul>
<p>The RecordDescriptor class has a few more constructors concerned with
joins and <a href="multiple-databases.html">accessing multiple
databases</a>, but that’s not important for now. The basic structure
described above is what you work with most of the time.</p>
<h2 id="attribute-type-mapping">Attribute Type Mapping</h2>
<p>The following table illustrates the mapping of Java object attribute
types to SQL database field types as they are supported by PriDE. The
row <em>‘JDBC type’</em> determines the type being used for the
specified attribute type to access results from a JDBC ResultSet or to
pass inputs to a JDBC PreparedStatement. The <em>‘SQL type’</em>
specifies the actual SQL row types, the attributes can usually be mapped
to. Not all SQL databases support all the mentioned type identifiers and
it may also depend on the JDBC driver’s capabilities which mappings are
supported. Primitive attribute types should of course only be used, if
the corresponding row must not be NULL. Otherwise an exception will be
thrown at runtime when attempting to process NULL values.</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 25%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr>
<th><strong>Java attribute type</strong></th>
<th><strong>JDBC type</strong></th>
<th><strong>SQL type</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>String</td>
<td>VARCHAR, VARCHAR2, NVARCHAR2, CHAR</td>
</tr>
<tr>
<td>java.util.Date</td>
<td>java.sql.Date</td>
<td>DATE, DATETIME, TIMESTAMP, TIME</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>java.sql.Date</td>
<td>DATE, DATETIME, TIMESTAMP, TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>java.sql.Timestamp</td>
<td>DATETIME, TIMESTAMP, TIME</td>
</tr>
<tr>
<td>java.time.LocalDate</td>
<td>java.sql.Date</td>
<td>DATE, DATETIME, TIMESTAMP, TIME</td>
</tr>
<tr>
<td>java.time.LocalDateTime</td>
<td>java.sql.Timestamp</td>
<td>DATE, DATETIME, TIMESTAMP, TIME</td>
</tr>
<tr>
<td>int / Integer</td>
<td>Integer</td>
<td>INTEGER</td>
</tr>
<tr>
<td>float / Float</td>
<td>Float</td>
<td>DECIMAL, REAL</td>
</tr>
<tr>
<td>double / Double</td>
<td>Double</td>
<td>DECIMAL, REAL</td>
</tr>
<tr>
<td>Any enum</td>
<td>String</td>
<td>VARCHAR, VARCHAR2, NVARCHAR2, CHAR</td>
</tr>
<tr>
<td>boolean / Boolean</td>
<td>Boolean</td>
<td>BOOLEAN, INTEGER, SMALLINT, TINYINT, CHAR</td>
</tr>
<tr>
<td>BigDecimal</td>
<td>BigDecimal</td>
<td>DECIMAL, NUMBER</td>
</tr>
<tr>
<td>long / Long</td>
<td>Long</td>
<td>INTEGER, DECIMAL, NUMBER, BIGINT</td>
</tr>
<tr>
<td>short / Short</td>
<td>Short</td>
<td>INTEGER, SMALLINT, TINYINT, DECIMAL</td>
</tr>
<tr>
<td>byte / Byte</td>
<td>Byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>byte[]</td>
<td>byte[]</td>
<td>BLOB, LONGVARBINARY, VARBINARY</td>
</tr>
<tr>
<td>java.sql.Blob</td>
<td>java.sql.Blob</td>
<td>BLOB, LONGVARBINARY, VARBINARY</td>
</tr>
<tr>
<td>java.sql.Clob</td>
<td>java.sql.Clob</td>
<td>CLOB, LONGVARCHAR</td>
</tr>
<tr>
<td>java.sql.SQLXML / String</td>
<td>java.sql.SQLXML</td>
<td>java.sql.SQLXML</td>
</tr>
</tbody>
</table>
<p>Clobs and Blobs can only be used through PreparedStatements, i.e. you
either have to access the entities with Clob / Blob attributes with
PriDE’s <a href="prepared-operations.html">prepared operations</a> or
you configure PriDE to use bind variables by default (see <a
href="quick-start-tutorial.html">quick start tutorial</a>).</p>
<p>The precision of dates and time stamps in the database vary
significantly between different database vendors. E.g. although date
rows were originally intended to represent dates without time portions
in SQL databases, Oracle allows seconds precision instead and so does
PriDE for Oracle. When using PriDE with plain SQL, dates and timestamps
are rendered by appropriate database-specific formating functions like
<code>to_date</code> or <code>to_timestamp</code> in Oracle, preserving
the same precision as it applies to prepared statements.</p>
<p>The interface <code>pm.pride.ResourceAccessor</code> provides the
constant <em>SYSTIME_DEFAULT</em>. In update and insert operations this
values will be translated to an expression which addresses the current
database server time like <em>CURRENT_TIMESTAMP</em> in MySQL or
<em>SYSDATE</em> in Oracle. This translation is only applied in plain
SQL.</p>
<p>You can tell PriDE to map a java.util.Date attribute to an SQL time
stamp by providing the JDBC type in the row definition of the record
descriptor as an additional parameter like that:</p>
<pre><code>.row(&lt;columnname&gt;, &lt;getter&gt;, &lt;setter&gt;, java.sql.Timestamp.class)</code></pre>
<p>There are a few more type conversions which can be expressed that
way. E.g. Enums can be represented by their ordinals in the database by
providing <code>java.lang.Integer.class</code> as additional parameter
for the mapping of the corresponding attributes.</p>
<p>The general pattern for arbitrary type conversion is to provide
appropriate additional getter/setter pairs which encapsulate the
conversion. To make clear, that these getters / setters are for internal
use only, it is common practice to give the method names a leading
underscore. Assume you have an enumeration type for coins with their
value in cent like that:</p>
<pre><code>public enum Coin {
    FIVE_CENT(5), FIFTY_CENT(50), ONE_EURO(100);
    
    private int valueInCent;
    Coin(int valueInCent) { this.valueInCent = valueInCent; }
    int value() { return valueInCent; }
}</code></pre>
<p>If you map an attribute of this type to the database, PriDE expects
an SQL row of type VARCHAR or a similar type to store values like
‘FIVE_CENT’ etc. If you want to represent the coins by their value in
the database, you provide a type-converting getter-setter-pair for the
corresponding attribute in the entity class:</p>
<pre><code>class MyEntity {
    private Coin myAttr;
    
    public int _getMyAttr() {
        return myAttr.value();
    }
    
    public void _setMyAttr(int v) {
        for (Coin coin: Coin.values()) {
            if (coin.value() == v) {
                myAttr = coin;
                return;
            }
        }
        throw new IllegalArgumentException();
    }
}</code></pre>
<p>Now you can use this getter setter pair to map the myAttr attribute
to a DECIMAL table row, holding the coins’ values:</p>
<pre><code>.row(&quot;MYATTR&quot;, &quot;_getMyAttr&quot;, &quot;_setMyCoin&quot;)</code></pre>
<div class="subpage-navigation">
<p>
<a id="prev" href="quick-start-tutorial.html"> Prev.</a> |
<a id="next" href="find-and-query.html">Next </a>
</p>
</div>
				</div>
			</section>

			<script src="https://j-pride.github.io/assets/js/jquery.min.js"></script>
			<script src="https://j-pride.github.io/assets/js/skel.min.js"></script>
			<script src="https://j-pride.github.io/assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="https://j-pride.github.io/assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="https://j-pride.github.io/assets/js/main.js"></script>
</body>
</html>
