<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Entity, Adapter, and Descriptor</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../assets/css/main.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
		<div class="subpage-menu">
			<a href="index.html"><i class="fa fa-home"></i> Home</a>
		</div>
		<section id="three" class="wrapper">
			<div class="inner">
<header id="title-block-header">
<h1 class="title">Entity, Adapter, and Descriptor</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#descriptor-structure">Descriptor structure</a></li>
</ul>
</nav>
<p>The concept of O/R mapping requires three basic building blocks:</p>
<ul>
<li>Entity classes which representing data in SQL tables - in the most common usage one entity object represents one record in one SQL table</li>
<li>Descriptors, describing how the entity classes map to the database</li>
<li>An adapter which reads data from the database to entities (select) and writes data from entities to the database (insert, update, delete)</li>
</ul>
<p>There are very different approaches around how to express the descriptor. JPA uses annotations on entity classes, MyBatis uses XML files, and PriDE follows a different approach as you may have seen already from the <a href="quick-start-tutorial.html">quick start tutorial</a>. The descriptor is an instance of class pm.pride.RecordDescriptor, i.e. it is code itself. This concept has a few advantages over other approaches.</p>
<ul>
<li>It does not clutter the entity classes with database details, so entities can be passed around in the application without violating the information hiding principle. If you are familiar with JPA you may have experienced the problem that mapping annotations can pile up to an annoying amount.</li>
<li>Its not written in a different language which is always hard to keep in sync with the Java code. This becomes a serious problem when applications grow over time. If you are only working with three database tables, you won’t have this problem, of course.</li>
<li>If it is Java code, it can be tied to any other related Java code by using shared constants for table named and row names and so on. This allows you to easily keep track of dependencies in the code. E.g. if you remove a column from a database table you will remove the appropriate constant in the code and every mentionable IDE will immediately lead you to all the places in the code that do not compile any more. This will include the descriptor as well as all the database queries in the code that refer to that column.</li>
<li>Descriptors may also be assembled dynamically at runtime. You hopefully will not often run into situations where you need that, but its good to know that there is no limit on that.</li>
</ul>
<p>A coded descriptor needs to go somewhere in your code, of course. PriDE provides two default patterns for the descriptor placement which are obvious when you think of the building blocks mentioned above: descriptors within adapter classes or descriptors within entity classes.</p>
<p>Descriptors in entities is what you know already from the <a href="quick-start-tutorial.html">quick start tutorial</a>. It cases the entities to become their own adapters having their own persistence methods. This is a compact pattern which is suitable for small applications. Therefore you will find it spread over most examples provided with PriDE. The disadvantage is the same one mentioned above with JPA: the entity classes spread knowledge about database mapping information all over the code. Combined with persistence capabilities directly incorporated in entity classes, this is a questionable concept in bigger architectures.</p>
<p>Let’s have a look on the more sophisticated pattern of separate adapter classes. You can have a look on the general structure by generating separate classes for the quick start example table. The pure entity class can be generated by the following command:</p>
<pre><code>java
-D... see quick start tutorial
pm.pride.util.generator.EntityGenerator CUSTOMER adapter.CustomerEntity -b &gt; CustomerEntity.java</code></pre>
<p>The parameter -b tells the generator to create only an entity class without descriptor. The result is an ordinary POJO class:</p>
<pre><code>package adapter;

public class CustomerEntity implements Cloneable, java.io.Serializable {
    private long id;
    private String name;
    private String firstName;

    public long getId()   { return id; }
    public String getName()   { return name; }
    public String getFirstName()   { return firstName; }

    public void setId(long id) { this.id = id; }
    public void setName(String name) { this.name = name; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    // re-constructor
    public CustomerEntity(long id) {
        setId(id);
    }

    public CustomerEntity() {}
}</code></pre>
<p>The “re-constructor” is an additional constructor getting passed a value for all the attributes making up the entity’s primary key. This of interest for find operations.</p>
<p>Generating the corresponding adapter class looks like this:</p>
<pre><code>java
-D... see quick start tutorial
pm.pride.util.generator.EntityGenerator CUSTOMER adapter.CustomerAdapter adapter.CustomerEntity &gt; CustomerAdapter.java</code></pre>
<p>The first parameter after the table name specifies the class to generate - in this case a class called CustomerAdapter in package adapter. The second parameter is the name of a entity class the adapter should refer to. The result looks like this:</p>
<pre><code>package adapter;

public class CustomerAdapter extends ObjectAdapter {
    public static final String TABLE = &quot;CUSTOMER&quot;;
    public static final String COL_ID = &quot;id&quot;;
    public static final String COL_NAME = &quot;name&quot;;
    public static final String COL_FIRST_NAME = &quot;first_name&quot;;

    protected static final RecordDescriptor red = new RecordDescriptor
        (CustomerEntity.class, TABLE, null, new String[][] {
            { COL_ID,   &quot;getId&quot;,   &quot;setId&quot; },
            { COL_NAME,   &quot;getName&quot;,   &quot;setName&quot; },
            { COL_FIRST_NAME,   &quot;getFirstName&quot;,   &quot;setFirstName&quot; },
        });

    public RecordDescriptor getDescriptor() { return red; }

    private static String[] keyFields = new String[] { COL_ID };
    public String[] getKeyFields() { return keyFields; }

    CustomerAdapter(CustomerEntity entity) { super(entity); }
}</code></pre>
<p>All what the adapter class has to provide is a RecordDescriptor and an optional list of column names making up the entity’s primary key. Based on that, the class inherits all entity-related persistence capabilities from class pm.pride.ObjectAdapter. Adapters always operate on an instance of the entity class which must be passed in the adapter’s constructor. Finding a customer by its primary ID looks like this when using separate adapter classes:</p>
<pre><code>// Create a customer entity, initialized with a primary key value of 1
CustomerEntity customer = new CustomerEntity(1);

// Create an adapter based on the entity
CustomerAdapter adapter = new CustomerAdapter(customer);

// Call the adapter&#39;s find method to find a customer by primary key 1.
// The primary key value is read from the entity passed in the adapter&#39;s constructor
// The result (if any) is written to the same entity
adapter.find();</code></pre>
<p>As you see, every persistence operation now requires one additional line of code to create the adapter. Especially when you design a multi-threaded application, it is important to know that adapter and entity instances are not supposed to be shared among multiple threads. So creating new instances in every operation is the prefered technique and is usually not a considerable code complication.</p>
<p>If you want to minimize the amount of code, you are free to invent your own adapter concept. Have a look on the base classes pm.pride.ObjectAdapter for the adapter above and pm.pride.MappedObject for the hybrid variant from the <a href="quick-start-tutorial.html">quick start tutorial</a>. Both are minimalistic implementations of the mix-in pm.pride.DatabaseAdapterMixin which is the actual provider for all entity-related persistence operations. It is in turn based on the static methods of the class pm.pride.DatabaseAdapter. Using this class or the mix-in you could easily produce a generic adapter being responsible for multiple entity types similar to JPA’s EntityManager interface.</p>
<p>One note concerning packages: When you actually use the pattern of separate adapters in a sophisticated architecture, you should consider generating entity and adapter classes in different packages. Only the entity classes should be part of the interface for dependent code while the adapter classes should completely be hidden behind facade components as proposed in the wide-spread <a href="https://martinfowler.com/eaaCatalog/repository.html">repository pattern</a>.</p>
<h2 id="descriptor-structure">Descriptor structure</h2>
<p>The examples for descriptors you have seen so far should already clarify most of their structure. You will see more complicated examples in following chapters of this manual. A descriptor in assembled from the following information:</p>
<ul>
<li><p>The name of the entity class and the name of the database table which the entity class is mapped to. Preferably the table name is not specified as a string-literal but as a reference to a constant representing the table name. If you have a look on the outcome of PriDE’s code generator, there are appropriate constants generated and used.</p></li>
<li><p>A reference to the descriptor of a base class. This is of interest when you build up an inheritance hierarchy between entity classes as explained in chapter <a href="entity-inheritance.html">Entity Inheritance</a>.</p></li>
<li><p>An attribute description map in form of a two-dimensional string array. The array contains one sub array for every table column resp. entity class attribute consisting of</p>
<ul>
<li>The name of the database column (similar to table names: avoid using string-literals here)</li>
<li>The name of the getter method for the corresponding attribute in the entity class</li>
<li>The name of the setter method</li>
</ul>
<p>The methods are the ones which the adapter is supposed to transport entity attributes to the database via JDBC and vice versa. The getter methods’ return type implies which methods the adapter uses to access JDBC statements and result sets and how to translate the values to SQL syntax. Getters are mandatory whereas setters may be null in case of entity types that are never supposed to be written to the database. A typical example for this case are entity classes representing the result of SQL joins (see chapter <a href="joins.html">Joins</a>).</p></li>
</ul>
<p>The RecordDescriptor class has a few more constructors concerned with joins and <a href="multiple-databases.html">accessing multiple databases</a>, but that’s not important for now. The basic structure described above is what you work with most of the time.</p>
<div class="subpage-navigation">
<p>
<a id="prev" href="quick-start-tutorial.html"> Prev.</a> | <a id="next" href="find-and-query.html">Next </a>
</p>
</div>
				</div>
			</section>

			<script src="https://j-pride.github.io/assets/js/jquery.min.js"></script>
			<script src="https://j-pride.github.io/assets/js/skel.min.js"></script>
			<script src="https://j-pride.github.io/assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="https://j-pride.github.io/assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="https://j-pride.github.io/assets/js/main.js"></script>
</body>
</html>
