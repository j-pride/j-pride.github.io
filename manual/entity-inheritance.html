<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Entity Inheritance</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../assets/css/main.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
		<div class="subpage-menu">
			<a href="index.html"><i class="fa fa-home"></i> Home</a>
		</div>
		<section id="three" class="wrapper">
			<div class="inner">
<header id="title-block-header">
<h1 class="title">Entity Inheritance</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#inheritance-with-separate-adapters">Inheritance with separate adapters</a></li>
</ul>
</nav>
<p>From a technical point of view, entity inheritance is of interest to encapsulate basic design concepts in a base class which should apply to various entity types in the same way. The chapter <a href="find-and-query.html">Find and Query</a> already mentioned a few examples like a default public clone() method and a toString() method. Another typical reason is a stereotype set of table rows which should be present in each table like an auto-incremented technical ID, a creation time and a last modification time, or a lock counter for concurrency control by <a href="optimistic-locking.html">optimistic locking</a>.</p>
<p>As a simple example for inheritance, you can split up the Customer entity in a way that the ID is encapsulated in a separate entity class IdentifiedEntity which the Customer entity is derived from. This is based on the assumption that all entity classes should have a unique ID row which is a wide-spread concept.</p>
<p>Inheritance in PriDE is a bit inconvenient as you have to maintain more than one inheritance hierarchy. However, new tables and entities don’t shoot like mushrooms out of the ground, so there’s no reason to bother. Beside the entities, you also have to relate both entities’ descriptors, and if you are working with separate adapters, the adapter classes have to be derived from each other too. As long as you are using 1:1 mappings, you can let PriDE’s entity generator do most of the job. So here is how to generate the little inheritance hierarchy which you can find in directory <a href="https://github.com/j-pride/pride.pm/tree/master/src/examples/java/inheritance">examples/inheritance</a> in the PriDE delivery or on GitHub. You start with generating the base class. As the generator is based on table structures in a database and there is no such concept like “base classes” in SQL, you must ensure that the CUSTOMER table is already present (resp. any other table following the same pattern with a technical ID) . To generate a class which does not map all the columns, you specify the columns of interest as comma-separated list along with the table name when calling the generator:</p>
<pre><code>
java

util.EntityGeneratorWithExampleConfig

CUSTOMER(ID) inherit.AbstractHybrid &gt; AbstractHybrid.java
</code></pre>
<p>The call above uses the class EntityGeneratorWithExampleConfig mentioned at the end of the <a href="quick-start-tutorial.html">Quick Start Tutorial</a> to simplify the passing of configuration parameters. Adding column names to a table name, tells the generator, that this is only a partial mapping resulting in an abstract class like this:</p>
<pre><code>
abstract public class AbstractHybrid extends MappedObject implements Cloneable, java.io.Serializable {

    public static final String COL_ID = &quot;id&quot;;



    protected static final RecordDescriptor red = new RecordDescriptor

        (AbstractHybrid.class, null, null, new String[][] {

            { COL_ID,   &quot;getId&quot;,   &quot;setId&quot; },

        });



    public RecordDescriptor getDescriptor() { return red; }



    private static String[] keyFields = new String[] { COL_ID };

    public String[] getKeyFields() { return keyFields; }



    private int id;



    public int getId()   { return id; }

    public void setId(int id) { this.id = id; }



    // Re-constructor

    public AbstractHybrid(int id) throws SQLException {

        setId(id);

        findx();

    }



    public AbstractHybrid() {}



    public Object clone() throws CloneNotSupportedException {

        return super.clone();

    }



}
</code></pre>
<p>Note that there was no table name constant generated and no table name is specified in the RecordDescriptor. All this doesn’t make sense for an abstract base class. The derived Customer class is then generated by specifying the base class in the generator call:</p>
<pre><code>
java

util.EntityGeneratorWithExampleConfig

CUSTOMER inherit.DerivedCustomer

-h inherit.AbstractHybrid &gt; DerivedCustomer.java
</code></pre>
<p>It is important to know that the call requires the base class to be compiled first. The generator will determine the remaining columns to map from reading the meta data of the CUSTOMER table from the database and the mapping information from the base class <em>as byte code</em>. It is therefore mandatory to specify the base class as fully qualified name even if it resides in the same package. The result looks like this:</p>
<pre><code>
public class DerivedCustomer extends inherit.AbstractHybrid {

    public static final String TABLE = &quot;CUSTOMER&quot;;

    public static final String COL_NAME = &quot;name&quot;;

    public static final String COL_FIRST_NAME = &quot;first_name&quot;;



    protected static final RecordDescriptor red = new RecordDescriptor

        (DerivedCustomer.class, TABLE, inherit.AbstractHybrid.red, new String[][] {

            { COL_NAME,   &quot;getName&quot;,   &quot;setName&quot; },

            { COL_FIRST_NAME,   &quot;getFirstName&quot;,   &quot;setFirstName&quot; },

        });



    public RecordDescriptor getDescriptor() { return red; }



    private static String[] keyFields = new String[] { COL_ID };

    public String[] getKeyFields() { return keyFields; }



    private String name;

    private String firstName;



    public String getName()   { return name; }

    public String getFirstName()   { return firstName; }



    public void setName(String name) { this.name = name; }

    public void setFirstName(String firstName) { this.firstName = firstName; }



    // Re-constructor

    public DerivedCustomer(int id) throws SQLException {

        super(id);

    }



    public DerivedCustomer() {}



}
</code></pre>
<p>Note the following details:</p>
<ul>
<li><p>The class is not abstract and is derived from AbstractEntity</p></li>
<li><p>It contains only the attributes and corresponding getters and setters for the name and first name column.</p></li>
<li><p>The RecordDescriptor contains only mappings for these attributes and refers to the RecordDescriptor from the base class. The complete mapping for the CUSTOMER table is assembled from both descriptors.</p></li>
<li><p>The re-constructor doesn’t call the findx() method but the super re-constructor from AbstractEntity instead which already does the find job. The base class will consider <em>all</em> the mappings because the derived class overrides the methods getDescriptor() and getKeyFields().</p></li>
</ul>
<p>The resulting DerivedCustomer class behaves exactly like the Customer class from the <a href="quick-start-tutorial.html">Quick Start Tutorial</a>. You can check that by running the CustomerClient from the quick start tutorial in parallel with the equivalent DerivedCustomerClient from the examples/inherit directory. Both have the same functionality and operate on the same table but work with the two different entity representations. This reveals an important fact about PriDE’s concept how inheritance is mapped to SQL where you don’t find such a concept. In terms of JPA, PriDE follows the <a href="https://en.wikibooks.org/wiki/Java_Persistence/Inheritance#Example_table_per_class_inheritance_tables_in_database">table-per-class strategy</a>. For every non-abstract class in the hierarchy there must exist a database table with columns for <em>all</em> mapped attributes of the class itself and <em>all</em> its super classes.</p>
<h2 id="inheritance-with-separate-adapters">Inheritance with separate adapters</h2>
<p>When you are working with separate adapters, you need a derivation for both, entity class and adapter class. The generator calls look like that:</p>
<pre><code>
## Entity base class

java util.EntityGeneratorWithExampleConfig

CUSTOMER(id) inherit.AbstractEntity -b



## Adapter base class

java util.EntityGeneratorWithExampleConfig

CUSTOMER(id) inherit.AbstractAdapter inherit.AbstractEntity



## Derived Customer entity class

java util.EntityGeneratorWithExampleConfig

CUSTOMER inherit.DerivedCustomerEntity -b inherit.AbstractAdapter



## Derived Customer adapter class

java util.EntityGeneratorWithExampleConfig

CUSTOMER inherit.DerivedCustomerAdapter inherit.DerivedCustomerEntity inherit.AbstractAdapter
</code></pre>
<p>An important detail is that generating the derived bean class requires to specify the base <em>adapter</em> class, not the base <em>entity</em> class in the generator call. In fact the generator needs to know about both, but the entity class can be determined from the adapter class’ record descriptor. The pure base entity class however doesn’t know about its mapping - that’s lastly the goal of the separation ;-)</p>
<p>The output of these generator calls is a very straight-forward separation of the hybrid code above. There is nothing tricky to know about. You can find the outcome in the examples/inherit directory from the PriDE delivery resp. on GitHub.</p>
<p>Entity inheritance hierarchies are of course not limited in their depth. E.g. if it were a typical pattern that entities have names, try this command and have a look on the output:</p>
<pre><code>
java util.EntityGeneratorWithExampleConfig

CUSTOMER(name) inherit.AbstractNamedHybrid -h inherit.AbstractHybrid
</code></pre>
<p>What PriDE does not support are queries based on abstract base entities which automatically consider the tables of the derived non-abstract entities. You can find features like that in JPA, but they require a highly complicated, obscure SQL query assembly - in combination with the table-per-class strategy resulting in SQL union expressions. This is something, which doesn’t happen too often and should always remain in the developer’s responsibility to stay on control of your SQL.</p>
<div class="subpage-navigation">
<p>
<a id="prev" href="insert-update-and-delete.html"> Prev.</a>
</p>
</div>
				</div>
			</section>

			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="assets/js/main.js"></script>
</body>
</html>
