<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Insert, Update, and Delete</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../assets/css/main.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
		<div class="subpage-menu">
			<a href="index.html"><i class="fa fa-home"></i> Home</a>
		</div>
		<section id="three" class="wrapper">
			<div class="inner">
<header id="title-block-header">
<h1 class="title">Insert, Update, and Delete</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#insert">Insert</a></li>
<li><a href="#transactions">Transactions</a></li>
<li><a href="#update">Update</a></li>
<li><a href="#delete">Delete</a></li>
</ul>
</nav>
<p>The basic functionality for inserting, updating and deleting data is very simple. In addition to the basics, this chapter also explains how to manage transactions which is of course a very important issue when you manipulate the data. For most code snippets in this chapter you can find example code in the directory <a href="https://github.com/j-pride/pride.pm/tree/master/src/examples/java/modify">examples/modify</a> in the PriDE delivery and on GitHub.</p>
<h2 id="insert">Insert</h2>
<p>To insert a record in a database table, you create an instance of the corresponding entity class, set all its attributes and call its create() method:</p>
<pre><code>Customer customer = new Customer();
customer.setId(57);
customer.setName(&quot;Fingal&quot;);
customer.setFirstnae(&quot;Paddy&quot;);
customer.create();</code></pre>
<p>When you are working with separate adapters instead, create() is a method of the adapter and the code looks like that:</p>
<pre><code>CustomerEntity customer = new CustomerEntity();
customer.setId(57);
customer.setName(&quot;Fingal&quot;);
customer.setFirstnae(&quot;Paddy&quot;);
new CustomerAdater(customer).create();</code></pre>
<p>You can insert multiple records successively using the same entity (and adapter) by changing the entity’s data and repeatedly call create(). This is OK for small amounts of inserts. If you have to insert thousands or hundreds of thousands records, you better work with the class pm.pride.PreparedInsert as explained in chapter <a href="mass-operations.html">Mass Operations</a>.</p>
<p>If the addressed database table has auto-increment rows, you can specify these rows in the adapter class resp. the hybrid entity class by the method public <code>String[] getAutoFields()</code>. In this case you leave the appropriate attributes uninitialized, and after creation PriDE will set them according to the values generated by the database. Expressing auto-incrementation in a database table definition is always a bit vendor-specific as well as the supported generation features in general. Supposed you are still experimenting with the SQLite database from the <a href="quick-start-tutorial.html">Quick Start Tutorial</a>, you could change the CUSTOMER table as follows to make the ID and auto-increment row:</p>
<pre><code>create table CUSTOMER (
    id integer not null primary key AUTOINCREMENT,
    name varchar(20),
    first_name varchar(30)
);</code></pre>
<p>An appropriate hybrid entity class looks exactly like the one from the Quick Start Tutorial only extended by the following line:</p>
<pre><code>public String[] getAutoFields() { return keyFields; }</code></pre>
<p>Based on that, the following loop creates 10 unique test customers in a row and prints out the auto-generated ID of each of them:</p>
<pre><code>Customer customer = new Customer();
for (int i = 0; i &lt; 10; i++) {
    customer.setName(&quot;Fingal-&quot; + i);
    customer.setFirstName(&quot;Paddy-&quot; + i);
    customer.create();
    System.out.println(customer.getId());
}</code></pre>
<p>You find an example for a customer class with auto-increment ID in directory <a href="https://github.com/j-pride/pride.pm/tree/master/src/examples/java/modify">examples/modify</a> in the PriDE delivery.</p>
<h2 id="transactions">Transactions</h2>
<p>Try to write a loop as above without anything else and you will recognize that it does not produce any rows at all in you CUSTOMER table. Most SQL databases are fully transaction-saved by default and thus require the application to properly commit its work. The foundation for transaction management with commit and rollback is the <a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">ACID principle</a>, which every developer must be well aware of as it is deep-seated in JDBC and every JDBC-based persistence manager.</p>
<p>In a JSE environment you will by default lose all your database work when the application terminates and you forgot to explicitly run a commit operation. In enterprise environments like standard JEE or Spring the application is usually not responsible for ending transactions by programmatic operations. Most applications use so-called container-managed transactions which are implicitly controlled by method annotations and exception handling. This is a very convenient and recommendable technique and it is also the key for composing higher-level methods from calls of lower-level methods in an elegant way according to the <a href="http://principles-wiki.net/principles:single_level_of_abstraction">Single Level of Abstraction Principle</a>. No method has to worry about whether it is the very top-level of the (potentially still growing) composition tree.</p>
<p>PriDE does not really manage transactions by its own but relies on the transaction management of the environment it is used in. The link between PriDE and its environment is the ResourceAccessor interface and you have to install one somewhere in your application. The chapter <a href="jse-jee-and-resourceaccessor.html">JSE, JEE, and ResourceAccessor</a> will explain that in detail. Except in this chapter, all other examples in this manual are working on a simple JSE environments and use the class ResourceAccessorJSE. So here is how this resource accessor works concerning its simple connection management and the resulting transaction behavior:</p>
<ul>
<li>As soon as you access the database for the first time, the accessor opens a database connection and binds it to the current thread. I.e. all succeeding database operations within the same thread are performed on the same database connection.</li>
<li>The ResourceAccessorJSE has no connection pooling, i.e. the number of concurrently allocated database connections corresponds to the number of threads requiring access to the database. This is not a suitable model for server applications, but if you implement server components with PriDE, you will hopefully work in a JEE environment.</li>
<li>The current database transaction can be committed by the call <code>DatabaseFactory.getDatabase().commit()</code>. This addresses only the connection being bound to the current thread. After committing, the connection is kept open and related to the thread so that subsequent databases operations run without warming up a new connection.</li>
<li>Alternatively the commit can be initiated from any adapter resp. hybrid entity as well. This is especially of interest when working with multiple databases because the commit then refers to the database which the entity resides in whereas DatabaseFactory.getDatabase() refers to the database which was addressed at last. This will be explained in detail in chapter <a href="multiple-databases.html">Multiple Databases</a>. When you are working with a single database, these operations are equivalent.</li>
<li>Instead of committing you may rollback your work by calling the rollback() method either on the database object or an adapter resp. a hybrid entity.</li>
<li>The resource accessor explicitly turns off auto-commit for every allocated connection.</li>
</ul>
<p>Coming back to the example for customer creation above, the code must be completed as follows:</p>
<pre><code>Customer customer = new Customer();
for (int i = 0; i &lt; 10; i++) {
    // see above
}
customer.commit();</code></pre>
<p>As a result the code will either successfully create all 10 customers or non at all because the whole work of the loop is committed at once at the end. If any of the 10 insert operations fails with an exception, the commit call would be skipped. This causes the application to terminate without any commit which in turn causes and implicit rollback. If you write an application which runs for a long time and is supposed to survive severe exceptions (i.e. a UI client), you should pay some attention on making the application robust against accidentally unterminated transactions. A recommended Java feature for an appropriate safety net is the UncaughtExceptionHandler interface. You can install a handler to every thread which preventively performs a rollback call.</p>
<h2 id="update">Update</h2>
<p>Updating a record is performed by calling the update() method of the adapter resp. the hybrid entity. All fields returned from the adapter’s getKeyFields() method are used to identify the record and all other fields are updated. The code</p>
<pre><code>Customer paddy = new Customer(57);
paddy.setFirstName(&quot;Paddy&quot;);
paddy.update();
paddy.commit();</code></pre>
<p>results in the following SQL statements as you can see from the log file:</p>
<pre><code>select id,name,first_name from CUSTOMER where ( id = 57 ) 
update CUSTOMER set name = &#39;Fingal&#39;,first_name = &#39;Paddy&#39; where id = 57</code></pre>
<p>All update calls return the number of affected rows which should be 0 or 1 in case of an update by primary key. It’s up to you if you check the result. PriDE has no detection which attributes actually changed since an entity has been loaded, so it simply updates <em>all</em> attributes which are not part of the primary key. As PriDE has no instance and change management, updates always have to be explicitly performed by the application. If you are familiar with JPA, you may recognize that the concepts are very different concerning this aspect. The chapter <a href="pride-design-principles.html">PriDE Design Principles</a> explains why the much simpler approach of PriDE is not a loss.</p>
<p>Updating single rows by update() calls is OK for a limited number of operations per transaction. If you have to update thousands of records instead you should consider working with the class pm.pride.PreparedUpdate as explained in chapter <a href="mass-operations.html">Mass Operations</a>.</p>
<p>There are a few variants of the update() method available which allow to update multiple records at once. E.g. the method update(WhereCondition where, String… updatefields) can address the records of interest by a where condition. In these cases there are usually only particular fields requiring an update. The following example demonstrates how to change all first names from “Paddy” to “Patrick”:</p>
<pre><code>Customer customer = new Customer();
customer.setFirstName(&quot;Patrick&quot;);
int updates = customer.update(new WhereCondition(COL_FIRST_NAME, &quot;Paddy&quot;), COL_FIRST_NAME);
customer.commit();
System.out.println(updates + &quot; row(s) updated&quot;);</code></pre>
<p>The code above makes clear that multi-record updates are not necessarily best to understand when they are expressed by entity operations. Have a look on the resulting update statement which is pretty clear to understand:</p>
<pre><code>update CUSTOMER set first_name = &#39;Patrick&#39; where ( first_name = &#39;Paddy&#39; )</code></pre>
<p>If the entity layer is not appropriate, you have a lower level at hand using the class pm.pride.Database. You get access to the current database by the call <code>DatabaseFactory.getDatebase()</code>. Here is how the renaming update looks like with a combination of the Database class and the SQLExpressionBuilder:</p>
<pre><code>Database database = DatabaseFactory.getDatabase();
String operation = SQL.build(
    &quot;update @CUSTOMER set @FIRST_NAME = &#39;Patrick&#39; where ( @FIRST_NAME = &#39;Paddy&#39; ) &quot;,
    TABLE, COL_FIRST_NAME);
int updates = database.sqlUpdate(operation);
database.commit();
System.out.println(updates + &quot; row(s) updated&quot;);</code></pre>
<p>In this example, the SQL code is almost present in its native, well recognizable form but it is still based on the entity’s table and column name constants. The DRY principle and dependency tracking is kept up properly. The commit is performed on the Database instance as explained in section <a href="transactions.html">Transactions</a> above.</p>
<h2 id="delete">Delete</h2>
<p>To delete a record you have to call the delete() method of the adapter resp. the hybrid entity. All fields returned from the adapter’s getKeyFields() method are used to identify the record All other fields are ignored, so whether they are initialized or not is irrelevant. The following code deletes the customer with ID 57:</p>
<pre><code>Customer c57 = new Customer();
c57.setId(57);
paddy.delete();
paddy.commit();</code></pre>
<p>Note that the code above is based on a hybrid entity and does not use the re-constructor which would immediately initiate a find operation. Entities don’t have to be loaded before deletion. Just like updates, every deletion returns the number of affected rows and it’s up to you if you check the result.</p>
<p>There is a deleteByExample() method available which allows to specify a different set of key attributes and usually deletes multiple records at once. More complicated multi-record deletions can be performed by the sqlUpdate() method of the Database class as introduced before in the <a href="update.html">section about updates</a>.</p>
<div class="subpage-navigation">
<p>
<a id="prev" href="find-and-query.html"> Prev.</a>
</p>
</div>
				</div>
			</section>

			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="assets/js/main.js"></script>
</body>
</html>
